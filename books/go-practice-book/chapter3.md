---
title: "第3章：関数と構造体・メソッド"
free: true
---

# 第3章　関数と構造体・メソッド

## 3.1 はじめに

前章までに、Go 言語で**変数を宣言**したり、**スライスやマップ**を使ってデータを操作したり、また**制御構文（if / for / switch）**で処理の流れを制御する方法を学んできました。これらを使えば、小規模なプログラムならば書けるようになったはずです。

しかし、**プログラムが大きく**なっていくと、「繰り返し使う処理」をまとめたり、「データとその操作」を整理する手段が欲しくなります。たとえば、

- 同じ計算処理を何度も書くと重複が多いので、一箇所にまとめたい  
- 1人のユーザの「名前・年齢・役職」などをまとめて扱いたい。さらに、そのユーザに特有の操作をまとめたい  
- 後でその“まとめ方”を変えたい時、なるべく影響範囲を小さく抑えたい  

こうした要望に応えるために、本章では

- **関数**：複数行にわたる処理をひとまとめにし、呼び出す際は関数名を使う  
- **構造体**：複数のフィールド（データ項目）をまとめて表せる型  
- **メソッド**：構造体（あるいは他の型）に“ひも付いた関数”のような仕組み  
- **可視性とパッケージ外への公開**：Go 言語における、大文字・小文字を使った可視範囲の制御  
- **(オプション) インターフェース**：メソッドの集合を“約束事”として定義し、それを満たすあらゆる型を共通の処理で扱える機能  
- **(オプション) ジェネリクス**：Go 1.18 以降で導入された新機能。型パラメータによる“型をまたいだ汎用的な関数や構造体”

などを学びます。**本章は内容が多岐にわたるため、まず「関数」「構造体・メソッド」に重点を置き、インターフェースとジェネリクスは後半のオプションとして解説**します。ご自身の興味や時間に合わせて読み進めていただいても構いません。

---

## 3.2 関数の定義と呼び出し

### 3.2.1 関数とは何か

すでに`main()` 関数の存在には慣れてきたかもしれませんが、Go 言語は「**関数**」という単位で処理をまとめる言語です。**関数** (function) とは、**入力（引数）を受け取り、計算をして、出力（戻り値）を返す**ひとまとまりの処理を指します。

- **例**: 数値を2倍にして返す関数  
  ```go
  func double(x int) int {
      return x * 2
  }
  ```

#### 3.2.1.1 関数を使うメリット

1. **同じ処理を繰り返し使い回せる**  
   例えば、2倍にするコードを何度も書かずに、`double(x)` を呼ぶだけで済む。  
2. **プログラムを整理できる**  
   大きな処理の流れを、「A という関数 → B という関数 → C という関数」と分割し、見通しを良くする。  
3. **テストやバグ修正が楽**  
   関数を独立させれば、そこだけ切り出してテストをしやすくなり、バグが起きたときも関数単位で調査できる。

### 3.2.2 関数の書き方・呼び出し方

基本的な構文は以下のとおりです。

```go
func 関数名(引数の列) 戻り値の型 {
    // 本体
    // 必要なら return 戻り値
}
```

- 例: 「2つの整数を受け取り、その和を返す」  
  ```go
  func add(a int, b int) int {
      return a + b
  }
  ```
  - 呼び出し: `result := add(3, 5)`

#### 3.2.2.1 引数が複数ある場合

```go
func multiply(a, b int) int {
    return a * b
}
```

- Go では、同じ型の連続する引数は `a, b int` と書ける。  
- 違う型が混じるなら `func example(x int, msg string) { ... }` のように書く。

#### 3.2.2.2 戻り値が複数ある場合

Go の特長として、「戻り値を2つ以上返せる」という仕組みがあります。これにより、**エラーと正常結果**を同時に返す書き方などが簡単に行えます。

```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}
```

- 上記のように `(int, error)` を戻り値とすれば、「正常時は `(quotient, nil)`, エラー時は `(0, error)`」という形で分けられます。  
- 呼び出し側は `q, err := divide(10, 2)` のように複数変数へ受け取る。

---

### 3.2.3 短いミニ問題：関数の定義

**問題**: 以下の関数を完成させてください。

- **課題**:  
  1. 引数として「整数のスライス」と「探索したい整数 `target`」を受け取る。  
  2. スライスの中に `target` が含まれていればその添字(index)を返し、含まれていなければ `-1` を返す。  
  3. スライスが空の場合も `-1` を返す。

```go
func findIndex( /* ここを埋める */ ) /* 戻り値も書いてください */ {
    // スライスが空なら -1 を返す
    // スライスの中をループして、もし target を見つけたら その index を return
    // 見つからない場合は -1 を return
}
```

**頭で考えてみてください**:  
- 引数の型や戻り値の型をどう書くか  
- `range` 文や `for i := 0; i < len(...); i++` のどちらでループするか

解答例は章末に用意してもよいし、すぐ示しても構いません。**頭で解いてから**コードに書いて動かしてみるプロセスを挟むと、論理的思考の訓練になります。

---

### 3.2.4 スコープとローカル変数

Go で関数を定義するときは、「関数の中で作った変数」は**関数の外から直接見えない**、というスコープ（可視範囲）ルールがあります。これはエラーを防ぎ、コードを安全にするための基本です。

- **例**:
  ```go
  func example() {
      x := 10
      // xはここでしか使えない
  }
  // ここに来ると x は消える
  ```

関数内で宣言した変数 `x` は、その関数のブロック `{}` 内だけで有効で、外に漏れません。この「隠蔽」が大きなメリットをもたらし、**別の関数の変数名と衝突しない**とか**意図せず書き換えられない**などの良い点があります。

*(なお、構造体とパッケージ外への公開については 3.4 と 3.5 でより詳しく扱います。ここでは「関数内の変数スコープ」として理解すれば十分です。)*

---

### 3.2.5 バグ入りコード演習：関数の戻り値がおかしい

ここでは、少しパズル感覚のバグ修正問題を示します。以下のコードにバグが仕込まれており、**本来期待する結果**が得られない状態です。どこをどう直せばいいか考えてみましょう。

```go
package main

import "fmt"

func sumRange(a int, b int) int {
    total := 0
    if a > b {
        // ここで逆にして計算するつもりが...
        tmp := a
        a = b
        b = tmp
    }

    for i := a; i <= b; i++ {
        // total を足す場所
        total = a + b // ← ???
    }
    return total
}

func main() {
    res := sumRange(3, 5)
    fmt.Println("sumRange(3,5) =", res)  // 本来なら 3+4+5=12
}
```

**観察ポイント**:  
- `for i := a; i <= b; i++ { ... }` の中で毎回何を足すべき？  
- 「短い行数の中にもおかしな書き方が混ざっている」ことに気づけるか  
- 修正後 `sumRange(3,5) = 12` が出力されるか確認してください。

このように、関数を少しミスって書いただけで結果が大きくずれるのは、**よくあるバグ**です。自分で発見・修正する練習を繰り返すと、論理思考力を鍛えつつ、Go 言語の基本的なデバッグのしかたにも慣れていきます。

---

## 3.3 構造体とメソッド

### 3.3.1 構造体：複数フィールドのまとまり

#### 3.3.1.1 何をするか

プログラムで扱うデータが増えてきたとき、単なる変数だけでは煩雑になりがちです。**構造体 (struct)** を使うと、「いくつかのフィールド」をひとまとめの型として定義できます。たとえば、人を表す場合なら `Name, Age, Address` を 1 つの構造体として扱えます。

```go
type Person struct {
    Name    string
    Age     int
    Address string
}
```

#### 3.3.1.2 なぜ使うか

1. **関連するデータをまとめる**  
   たとえば、名前・年齢・住所を別々の変数で扱うよりも、“Person” という 1 つの塊にできるほうが読みやすいし、管理しやすい。  
2. **メソッドを定義しやすい**  
   後述の「メソッド」で、この構造体に何か操作(挙動)を持たせることも可能。  
3. **複雑なプログラムの整理**  
   プログラムが大きくなるほど、データ同士の関係を意識するのが重要。構造体はその第一歩となる仕組みです。

#### 3.3.1.3 どう書くか

```go
type Person struct {
    Name string
    Age  int
}
```

- **`type Person struct { ... }`** は、`Person` という名前の構造体型を定義している。  
- 使うときは `var p Person` で変数を作り、`p.Name = "Alice"` などと代入。  

##### 代入例

```go
func main() {
    var p Person
    p.Name = "Alice"
    p.Age = 30
    fmt.Println(p)
}
```

これを実行すると、`{Alice 30}` のように構造体の中身が表示されます（Go の構造体はデフォルトでフィールド名は出力されない）。表示をカスタマイズしたいときは、後述する「メソッド」や「`fmt`パッケージの書式指定」を活用します。

---

### 3.3.2 メソッド

#### 3.3.2.1 何をするか

**メソッド**とは、特定の型に「紐づいた関数」です。たとえば、`Person` という構造体があるなら、`func (p *Person) Greet() { ... }` のように書くことで、「`Person` 型に `Greet` というメソッドが生えている」状態になります。

```go
func (p Person) Greet() {
    fmt.Printf("Hello, my name is %s. I am %d years old.\n", p.Name, p.Age)
}
```

- 呼び出し：`p.Greet()` と書ける。  

#### 3.3.2.2 なぜ使うか

1. **データと操作を関連づける**  
   `Person` に関わる処理を `Person` のメソッドとしてまとめることで、プログラムを分かりやすく保てる。  
2. **オブジェクト指向的な書き方**  
   Go は従来のオブジェクト指向言語と少し違うが、メソッドを定義すれば「構造体を中心に振る舞いをまとめる」スタイルが実現できる。  
3. **受け取り方 (値レシーバ or ポインタレシーバ)**  
   メソッドの定義で `(p Person)` と書くと“値レシーバ”、 `(p *Person)` と書くと“ポインタレシーバ”になる。後者のほうがフィールドを直接書き換えられる。

---

### 3.3.3 値レシーバとポインタレシーバ

Go 言語では、メソッドのレシーバ部分に `(p Person)` と書くか `(p *Person)` と書くかで挙動が変わります。

- **(p Person)**：値として受け取るので、メソッドの中で `p.Age = 10` など変更しても、呼び出し元の `Age` は変わりません（コピーをいじるだけ）。  
- **(p *Person)**：ポインタとして受け取るので、メソッドの中で `p.Age = 10` と書けば、呼び出し元の `Person` に直接変更が反映されます。

```go
func (p Person) NoChangeName(newName string) {
    p.Name = newName // これはコピーの中のNameを変えるだけ
}

func (p *Person) ChangeName(newName string) {
    p.Name = newName // オリジナルのPerson.Nameが変わる
}
```

> 初心者はつい値レシーバで書いて「更新してるつもりが反映されない」バグをよく起こす。ポインタか値かを正しく選んで、バグを防ぐ論理力も磨けます。

---

### 3.3.4 短いミニ問題：構造体とメソッド

**問題**: 以下の `Rect` 構造体（長方形）に対して、「`Area()` メソッドで面積を返す」「`Enlarge(factor int)` メソッドで縦横を `factor` 倍に伸ばす」2つのメソッドを定義してください。

```go
type Rect struct {
    Width  int
    Height int
}

// (1) 面積を返すメソッド
//     戻り値は int
//     呼び出し例: r.Area()
//
// (2) Enlarge(factor int) で
//     Width, Height を factor倍に更新する
//
// 値レシーバかポインタレシーバか？
// 考えてみよう
```

解答を自分で書いたら、短いテストコードや小さなmain関数で「`r := Rect{3,4} / r.Area() → 12」「r.Enlarge(2)して r.Width = 6」等を試し、期待通りか確認してください。内部を変えるメソッドならポインタレシーバが自然ですが、値レシーバでも書ける（ただし呼び出し元に変化が反映されない）といった違いに気づくと深まります。

---

### 3.3.5 構造体・メソッドにおける可視性

Go 言語では、**大文字で始まる識別子**は「パッケージの外部へ公開する」、小文字で始まると「パッケージ内部だけで使える」といったルールで可視性を制御します。

- **構造体**: `type person struct {...}` と小文字で始めると、パッケージ外からは `person` が見えなくなります。一方 `type Person struct {...}` と大文字なら公開されます。  
- **フィールド**: `Name string` のように大文字なら外部公開。`age int` のように小文字なら非公開。  
- **メソッド**: 同様に `(p Person) Greet()` は大文字始まりなら公開。 `(p Person) greet()` は内部用。

#### 3.3.5.1 なぜ必要か

1. **パッケージの境界**  
   - 同じパッケージの中では自由に扱いたいが、外からは勝手に書き換えられたくないフィールドを小文字で定義する。
2. **情報隠蔽**  
   - 公開されるフィールドやメソッドだけが外部の利用者に使われ、実装の詳細は隠せる。
3. **競合や誤使用を防ぐ**  
   - 大文字/小文字の区別により、エクスポート(公開)する対象を明示でき、設計上の意図を表せる。

これにより、**大文字・小文字**が「ローカルスコープ(関数内)とは別次元」で可視性を左右する重要な要素になります。構造体を外に使わせるなら大文字（例：`Person`）、内部専用なら小文字（例：`person`）など、プロジェクトの設計方針に合わせた命名が必要です。

---


### 3.3.6 ミニテスト(1)  
（対象範囲：**関数～メソッド・可視性**）

#### テスト内容
- **対象**: 第3章の前半（関数の定義/呼び出し、構造体/メソッド、可視性など）  
- **形式**:  
  1. 選択問題（複数択 or ○×）  
  2. 穴埋め問題（コード中の空欄を埋める）  

---

#### 3.3.6.1 選択問題：関数とローカル変数

1. Go言語で複数の戻り値を返す関数の例として正しいものはどれか。  
   - (A) `func divide(a, b int) int, error { ... }`  
   - (B) `func divide(a, b int) (int, error) { ... }`  
   - (C) `func divide(a, b int) (int)(error) { ... }`  
   - (D) `func divide(a, b int) error, int { ... }`  

2. 下記コードの動作を正しく説明している選択肢はどれか。  
   ```go
   func example() {
       x := 10
       if x > 5 {
           y := x * 2
       }
       fmt.Println(y) // ?
   }
   ```
   - (A) `y` は `if` の外でも参照できるので、出力される値は 20  
   - (B) `y` はブロック内の変数なので、コンパイルエラーが起きる  
   - (C) `y` はローカル変数だが、ブロックが終わっても残る  
   - (D) 何も出力されないが、理由は実行時エラーだから  

---

#### 3.3.6.2 選択問題：メソッド（値レシーバとポインタレシーバ）

以下にある `UpdateName` メソッドについての説明として最適な選択肢はどれか。

```go
type Person struct {
    Name string
    Age  int
}

func (p Person) UpdateName(newName string) {
    p.Name = newName
}
```

- (A) `p.Name` は必ず更新され、呼び出し元の `Person` にも反映される  
- (B) `p.Name` はコピーを操作しているため、元の `Person` は変わらない  
- (C) このコードはコンパイルエラーになる（メソッドは常にポインタレシーバが必要だから）  
- (D) `UpdateName` が実行されると自動的にAgeも更新される  

---

#### 3.3.6.3 穴埋め問題: 可視性（大文字/小文字）とメソッド

以下のコードは、パッケージ外に公開したい構造体 `Student` と、パッケージ内部でのみ使うメソッド `calcScore` を定義しています。空欄（Ａ）（Ｂ）（Ｃ）をそれぞれ大文字/小文字で補ってください。

```go
type (Ａ) struct {
    Name  string
    Score int
}

func (s (Ａ)) (Ｂ) {
    // このメソッドはパッケージ外でも呼べるようにする？
    fmt.Printf("Name=%s, Score=%d\n", s.Name, s.Score)
}

func (s *(Ａ)) (Ｃ) {
    // このメソッドはパッケージ内だけ
    // スコア計算の内部ロジック
    s.Score += 10
}
```

ヒント:
- (Ａ): 構造体を外部公開したいかどうか  
- (Ｂ): メソッドを外部公開したいかどうか  
- (Ｃ): メソッドを内部専用にしたいかどうか  

---

#### 3.3.6.4 穴埋め問題: 関数の複数戻り値

以下のコードは、「２つの整数を受け取り、`(結果, error)` を返す」関数の例ですが、一部が抜けています。空欄（Ｄ）（Ｅ）（Ｆ）を埋め、正しくコンパイルが通るようにしてください。

```go
func divide(a, b int) (Ｄ, Ｅ) {
    if b == 0 {
        return (Ｆ), errors.New("division by zero")
    }
    return a / b, nil
}
```

- (Ｄ): 戻り値の第1要素の型  
- (Ｅ): 戻り値の第2要素の型  
- (Ｆ): **「a / b」か「0」か**、エラー時に返す適切な値  

---

### 3.3.7 演習：生徒情報を扱うプログラムを完成させよう

#### 3.3.7.1. 目的

- **構造体 (Student)** や **メソッド** の使い方を身につける。  
- スライス操作の関数を定義し、データの追加や検索を行う流れを理解する。  
- メイン関数で実行し、最終的な動作を確認する。

#### 3.3.7.2. 課題の全体像

- **Student 構造体**を作り、いくつかの生徒を管理する。  
- **メソッド**を定義して、特定のフィールドを更新したり、情報を表示したりする。  
- **スライス操作の関数**（`AddStudent`、`FindStudentByID`、`PrintAll`）を用意し、メイン関数で実際に呼び出す。

#### 3.3.7.3. 詳細仕様

##### 3.3.7.3.1 Student 構造体の定義

以下のフィールドを持つ構造体 `Student` を作成してください。

1. `ID` (int型)  
   - 一意の番号
2. `Name` (string型)  
   - 生徒名
3. `Score` (int型)  
   - テストの得点

##### 3.3.7.3.2 メソッドを定義

1. `func (s *Student) UpdateScore(newScore int)`  
   - `Score` フィールドを `newScore` に上書きする  
   - **必ずポインタレシーバ**にすること。理由をコメントで書いてください（例：「値レシーバだと変更が反映されないため」など）。  

2. `func (s Student) PrintInfo()`  
   - 生徒情報を 1 行で表示する  
   - 形式例：  
     ```
     ID=1, Name=Alice, Score=80
     ```
   - レシーバは値でもポインタでも構いませんが、`PrintInfo()` がフィールドを更新しないなら値レシーバでもOKです。

##### 3.3.7.3.3 スライス操作の関数を用意

- (1) `AddStudent`

```go
func AddStudent(students []Student, stu Student) []Student
```

- 役割:  
  - 第2引数 `stu` をスライス `students` の末尾に追加し、新たなスライスを返す。
- 注意:
  - **必ず「新しいスライスを返す」形**にしてください。  
  - たとえば `students = append(students, stu)` の結果を返す。

- (2) `FindStudentByID`

```go
func FindStudentByID(students []Student, id int) *Student
```

- 役割:
  - `students` の中を検索し、引数 `id` に合致する `Student` を見つけたら、そのポインタを返す。  
  - 見つからなければ `nil` を返す。
- 注意:
  - 使う側は `if p == nil { ... }` のように判定できる。

- (3) `PrintAll`

```go
func PrintAll(students []Student)
```

- 役割:
  - `students` の全要素に対して、`PrintInfo()` を呼び出して表示する。  
- 注意:
  - あくまで1行ずつ `PrintInfo()` するだけで、何か返す必要はない。

##### 3.3.7.3.4 メイン関数で試す

以下の流れを必須とし、メイン関数を組み立ててください。

1. **スライスの初期化**  
   ```go
   var students []Student
   ```
2. **いくつかの生徒を追加**  
   ```go
   students = AddStudent(students, Student{ID: 1, Name: "Alice", Score: 80})
   students = AddStudent(students, Student{ID: 2, Name: "Bob", Score: 90})
   // など
   ```
3. **PrintAll で一覧表示**  
   ```go
   PrintAll(students)
   ```
4. **特定の ID を検索し、スコアを更新**  
   ```go
   p := FindStudentByID(students, 1)
   if p != nil {
       p.UpdateScore(95)
   }
   ```
5. **再度 PrintAll で一覧表示**  
   - 「Alice」の `Score` が 95 に変わっているか確認

#### 3.3.7.4. 実行例

以下は想定される出力の一例です。

```
ID=1, Name=Alice, Score=80
ID=2, Name=Bob,   Score=90
// Alice のスコアを 95 に更新
ID=1, Name=Alice, Score=95
ID=2, Name=Bob,   Score=90
```

本書の進め方では、行頭のスペースや整列は厳密ではありませんが、**少なくとも Score が書き換わっていること**を確認できれば OK です。

#### 3.3.7.5. 完成基準

以下の事項を満たしていれば、課題クリアです。

1. **Student 構造体**に `ID, Name, Score` の3フィールドを持たせた。  
2. メソッド  
   - `UpdateScore(newScore int)` → ポインタレシーバ  
   - `PrintInfo()` → 1 行で `ID=..., Name=..., Score=...` を出力  
3. **AddStudent** は新しいスライスを返し、**FindStudentByID** は無いなら `nil` を返す。  
4. **PrintAll** はスライスの全要素に対し `PrintInfo()` を呼ぶ。  
5. メイン関数で実行したとき、下記の一連の動きが確認できる。  
   - 生徒追加 → 一覧表示  
   - IDを検索 → `Score` を更新 → 再度一覧表示し変更が反映されている

ぜひこの順序に沿ってコードを組み立ててみてください。ゴールは、「**生徒追加 → 一覧 → スコア更新 → 一覧**」までが動く状態です。完了したら、コードの動作や出力を確認し、スライスや構造体、メソッド、可視性（大文字・小文字）などの学びを振り返ってみるとよいでしょう。

---

## 3.4 インターフェースによる抽象化

前半までに、**「関数」「構造体」「メソッド」**という概念を見てきました。これだけでもある程度、オブジェクト指向に近い作り方ができます。しかし、Go では**別の仕組みとして「インターフェース」**が大きな役割を担っています。インターフェースは、**「メソッドの一覧を定義し、それを全部実装している型ならこのインターフェースを満たす」**というものです。

「**宣言的なimplements**」はなく、Go は**「暗黙のimplements」**を採用している点が特徴です。つまり、ある型が `Speak()` メソッドを持つなら、それは自動的に「`Speak()`を要求するインターフェース」を満たしたとみなされるわけです。

本節では、**インターフェースの基本的な考え方**を学び、**複数の異なる型を共通処理にまとめる**など、Go らしい抽象化手法を体験していきます。

---

### 3.4.1 インターフェースとは

#### 3.4.1.1 基本構文

```go
type インターフェース名 interface {
    メソッドA(引数...) 戻り値...
    メソッドB(引数...) 戻り値...
    // ...
}
```

インターフェースを定義するときは、**`interface { ... }`** の中に「求めるメソッドのシグネチャ（名前、引数、戻り値）」を並べます。たとえば、`Speaker` インターフェースなら、

```go
type Speaker interface {
    Speak()
}
```

- これは「`Speak()` メソッドを持っていれば、Speaker インターフェースとして扱える」という意味。  

#### 3.4.1.2 なぜ使うのか

1. **異なる型を共通の操作で扱いたい**  
   例：`Cat` と `Dog` がそれぞれ「鳴く (Speak)」メソッドを持っているなら、`Speaker` インターフェースとして一括で管理できる。  
2. **依存関係を緩やかにする**  
   「ある型に依存しすぎると再利用性が落ちるが、インターフェースを介すことで“このメソッドを持つ何か”という形に抽象できる」。  
3. **Go の暗黙実装**  
   宣言的に「`Cat` は `Speaker` を implements する」と書く必要なく、ただ `Cat` に `Speak()` があればOK。これはシンプルで柔軟。

#### 3.4.1.3 簡単な例

```go
type Speaker interface {
    Speak()
}

type Cat struct {
    Name string
}

func (c Cat) Speak() {
    fmt.Println("Meow! I am", c.Name)
}

type Dog struct {
    Name string
}

func (d Dog) Speak() {
    fmt.Println("Woof! I'm", d.Name)
}

func main() {
    var s Speaker

    s = Cat{"Mittens"}
    s.Speak() // "Meow! I am Mittens"

    s = Dog{"Max"}
    s.Speak() // "Woof! I'm Max"
}
```

- Cat, Dog はともに `Speak()` メソッドを持つため、自動的に `Speaker` インターフェースを満たす。  
- `var s Speaker` として宣言した変数 `s` に、`Cat` も `Dog` も代入できる。

---

### 3.4.2 複数のメソッドを含むインターフェース

インターフェースは単にメソッド1つではなく、**複数のメソッド**を要求することもできます。例えば `Reader` インターフェースには `Read(p []byte) (n int, err error)` メソッドが必要、`Writer` インターフェースには `Write(p []byte) (n int, err error)` が必要、など。Go の標準ライブラリで `io.Reader` / `io.Writer` がこうしたモデルになっています。

#### 3.4.2.1 例：Reader/Writer

- **`io.Reader`**:  
  ```go
  type Reader interface {
      Read(p []byte) (n int, err error)
  }
  ```
  - ファイル、ネットワーク接続、文字列バッファなど、**“読み取りができるもの”**なら `Read()` メソッドを実装していれば `io.Reader` として扱える。  
- **`io.Writer`**:
  ```go
  type Writer interface {
      Write(p []byte) (n int, err error)
  }
  ```
  - 同様に、ファイル書き込み、メモリ書き込みなど、`Write()` を実装していれば `io.Writer` になる。  

#### 3.4.2.2 なぜ便利か

1. **抽象化**: コードの中で「`io.Reader` に読み込ませる」と書けば、それがファイルかネットワークかは関係なく、同じインターフェースとして扱える。  
2. **交換可能**: テスト時には偽物のReaderを使ってシミュレートするなど、実際のIOを変えることなくロジックを検証可能。  
3. **Go 標準ライブラリが広く採用**: ほとんどのI/Oが `Reader` / `Writer` インターフェースに基づき書かれているため、一度慣れると非常に拡張しやすい。

---

### 3.4.3 演習：インターフェースを使って出力

**問題**: あなたが「描画可能な図形」を表すインターフェース `Drawable` を定義し、以下を満たすように書いてみてください。

1. `Drawable` インターフェースは `Draw()` メソッドを要求する。  
2. `Circle` 構造体と `Rectangle` 構造体を定義し、それぞれが `Draw()` メソッドを実装。  
   - `Circle.Draw()`：`fmt.Println("Drawing Circle:", c.Radius)` のように出力  
   - `Rectangle.Draw()`：`fmt.Println("Drawing Rect w=", r.Width, "h=", r.Height)`  
3. `func DrawAll(items []Drawable)` を作り、`for _, it := range items { it.Draw() }` で一気に描画。  
4. メイン関数で `var shapes []Drawable` に `Circle` や `Rectangle` を入れて `DrawAll(shapes)` する。

これにより「違う構造体が同じインターフェースを共有」し、同じ関数 `DrawAll` を使って描画する流れがわかるはずです。ここでも、**暗黙のimplements**が働き、`Circle` と `Rectangle` は「Draw() メソッドがあるから `Drawable` に適合する」ことになります。

---

## 3.5 ジェネリクスと型パラメータ

Go 1.18 以降、**ジェネリクス (Generics)** という大きな機能が入りました。「複数の型に対応する関数や構造体」を作りたくなる場面は少なくないため、これまでインターフェースや `interface{}` (旧any) などを駆使していたのが、**ジェネリクスでコンパイル時に型をチェック**できるようになり、一層安全かつ表現力が増しました。

### 3.5.1 型パラメータとは何か

**型パラメータ**は、関数や構造体の定義に `<T>` のような形で“パラメータ”を与え、呼び出し側が「具体的な型（int, string, etc.）」を埋める仕組みです。たとえば、以下の `Stack[T any]` は「T という型を引数に持つジェネリック構造体」で、`Push` や `Pop` が T 型の要素を扱えます。

```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(elem T) {
    s.items = append(s.items, elem)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    last := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return last, true
}
```

- `T any` の部分は「`T` はどんな型でも可」という型制約を表す。  
- 使うとき：`var s Stack[int]` のように `int` を当てはめてスタックを作る。  
- これにより、スライスの中身を `int` として扱えるが、`string` を混ぜるとコンパイルエラーになる。

#### 3.5.1.1 なぜこうするか

- **インターフェースだけだとコンパイル時の型安全性が部分的**  
  例えば `interface{}` で受け取ると、実行時にキャストが必要で、間違った型を入れてもコンパイルでは気づけない。  
- **ジェネリクスは「型パラメータ」を導入し、呼び出し時にコンパイラが型の一致をチェック**  
  →「間違った型を入れたらエラー」「正しい型なら安全に扱える」  
- **再利用性**  
  一度作った `Stack[T]` は、`int` 用・`string` 用・`MyStruct` 用などあらゆる型に適用できるため、汎用データ構造を書くのに向いている。

---

### 3.5.2 簡単な例：ジェネリック関数で最大値を求める

```go
func max[T int | float64](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

- ここでは、「int か float64 のみ許容する」という型制約 `T int | float64` を書いている。`(a, b T)` とすれば、呼び出すときに `max(3,5)` なら `T` が `int` に推論されるし、`max(2.5, 3.7)` なら `T` が `float64` になる。  
- もし `max("hello","world")` のような呼び方をするとエラー。`string` は指定していないから。  
- “`any`” だけの制約にすると “あらゆる型が入る” ので、`>` 演算子をどう扱うかが問題になる（`any` だと`>`演算子を持たない型も含まれる）。こうした点で、「どの演算を使いたいか」に応じて型制約を細かく指定するのが Go 的なジェネリクスの特徴です。

#### 3.5.2.1 メリット / デメリット

- **メリット**  
  1. **コンパイル時チェック**: 実行時に “型が違う” と怒られるより早く、安全に不整合を弾ける。  
  2. **コードの再利用**: 同じロジックを複数の型でコピペする必要がない。  
- **デメリット**  
  1. **やや概念が難しい**: `T any`, `T constraints.Ordered`, `T ~int|~float64`, など独特の書式・ルールを覚える必要がある。  
  2. **実行ファイルサイズ**: 型の数だけ生成されるため、膨大な組み合わせを使うとバイナリが膨れがち。（ただし日常的にはそこまで問題にはならない）

---

## 3.6 ミニテスト(2)  
（対象範囲：**インターフェースとジェネリクス、応用**）

### テスト内容
- **対象**: 第3章後半（インターフェース、ジェネリクス、応用トピック）  
- **形式**:  
  1. 選択問題（複数択 or ○×）  
  2. 穴埋め問題（コード中に欠落した記述を補う）  

---

### 3.6.1  選択問題：インターフェース

1. Go のインターフェースにおいて、暗黙の実装とは何か。  
   - (A) インターフェースを実装する際に「implement」キーワードが不要で、メソッドが一致すれば自動的に認識される  
   - (B) インターフェースは明示的に `implements` 宣言を書くことで結びつく  
   - (C) 型が複数のインターフェースを同時に実装することはできない  

2. 次の型があるとき、`var r Reader` に代入できるのはどれか（複数選択可）。  
   ```go
   type Reader interface {
       Read(p []byte) (n int, err error)
   }

   type MyFile struct {}
   func (f MyFile) Read(p []byte) (n int, err error) { ... }

   type Writer interface {
       Write(p []byte) (n int, err error)
   }

   type MyBuffer struct {}
   func (b MyBuffer) Write(p []byte) (n int, err error) { ... }
   ```

   - (A) MyFile  
   - (B) MyBuffer  
   - (C) Writer  
   - (D) Reader  

(ヒント: MyBuffer は Write を実装しているが Read は実装していない)

---

### 3.6.2 選択問題：ジェネリクス

1. 以下のジェネリック関数はコンパイルエラーになりますが、その理由として適切なのはどれか。  
   ```go
   func max[T any](x, y T) T {
       if x > y {
           return x
       }
       return y
   }
   ```
   - (A) Go ではジェネリクスで戻り値を2つ以上取ることができない  
   - (B) `>` 演算子を使う型であることをコンパイラに伝えていない  
   - (C) `any` は旧 `interface{}` と同じなのでこれは何の問題もなく動く  

2. 「`constraints.Ordered`」とは何か。  
   - (A) Go 標準で定義される “比較可能 ( `<`, `>`, `==` などが使える )” 型制約  
   - (B) 大きさ順に並べられた定数群を定義するキーワード  
   - (C) ジェネリクスでは常に `constraints.Ordered` を明示しないとコンパイルエラーになる  

---

### 3.6.3 穴埋め問題：インターフェース＋ジェネリクス

次のコードは「比較インターフェース」を組み合わせてジェネリクス関数 `maxC` を書こうとしたものです。空欄（Ｇ）（Ｈ）（Ｉ）を適切に補ってください。

```go
type Comparable interface {
    (Ｇ)(other any) bool
}

func maxC[T (Ｈ)](x, y T) T {
    if x.(Ｇ)(y) {
        return x
    }
    return y
}
```

ここで、次のことが分かっている：
- Comparable インターフェースは「相手と比較し、true/false を返すメソッド」を要求する。
- maxC では「T が Comparable」を満たす必要があるため、(Ｈ) にはジェネリクスの「T (何か)」と書く。
- `(Ｇ)(y)` というメソッド呼び出しが成り立つには、Comparable が要求しているメソッド名を正しく書く必要がある。

ヒント：
- (Ｇ) は「メソッド名(別名)」
- (Ｈ) は「T がComparableである」ことを制約とする記述

---

### 3.6.4 穴埋め問題：ジェネリック Filter

以下のコードは、ジェネリック `Filter` 関数を定義するつもりですが、いくつか足りない部分があります。（Ｊ）と（Ｋ）を埋めて、コンパイルが通るようにしてください。

```go
func Filter[(Ｊ)](arr []T, pred func(T) bool) []T {
    var result []T
    for _, v := range arr {
        if (Ｋ)(v) {
            result = append(result, v)
        }
    }
    return result
}
```

- (Ｊ): ジェネリック型パラメータの宣言。「T という型パラメータを any として使う」  
- (Ｋ): `pred` という関数を呼び出す部分。変数名も正しく書く必要がある。

---

## 3.7 発展・応用トピック

ここでは、**前半**で学んだ**関数**と**構造体・メソッド**の応用例を、**インターフェース**や**ジェネリクス**と絡めていく形で紹介します。読者によっては、このあたりは「高度すぎる」と感じるかもしれませんが、「論理的パズルが得意」な方ならぜひ挑戦してみてください。短期であっても、一度経験しておくと後の章で役立つはずです。

## 3.7.1 小演習：Filter関数をジェネリクスで書く

**演習**: 「スライスの要素を条件に合うものだけ抜き出す `Filter` 関数」を、ジェネリクスで作ってみましょう。  
- プロトタイプ:  
  ```go
  func Filter[T any](items []T, pred func(T) bool) []T {
      // ここにロジックを書く
  }
  ```
  - `items` は `T` 型のスライス  
  - `pred` は「T を1つ受け取り bool を返す」関数  
  - `Filter` は、`pred(item) == true` となる要素だけを集めた新スライスを返す

**回答のポイント**:
```go
func Filter[T any](items []T, pred func(T) bool) []T {
    var result []T
    for _, it := range items {
        if pred(it) {
            result = append(result, it)
        }
    }
    return result
}
```

- これで**「int の配列から偶数だけ抜き出す」「string の配列から長さ3以上のものを抜き出す」**など、型を問わず再利用可能です。  
- 呼び出し例:
  ```go
  s := []int{1,2,3,4,5}
  even := Filter(s, func(n int) bool { return n%2==0 })
  fmt.Println(even) // [2 4]
  ```

---

### 3.7.2 構造体 + インターフェースでソート機能を抽象化

1. **問題設定**: “いくつかの構造体をスライスに格納し、メソッド `Less(other interface{}) bool` を使って大小比較を行うインターフェース” を考える。  
2. **なにをするか**:  
   - `Sortable` インターフェースを作り「`Less(other any) bool`」メソッドを持つ。  
   - `Person` がこれを満たすには、「`func (p Person) Less(o any) bool`」を実装し、たとえば年齢や名前の大小を比較して返す。  
   - `sort.Slice` のコールバック内で、この `Less` を呼び出すパターンが考えられる。  
3. **パズル要素**:  
   - “どうやって `other any` を実際の型にキャストするか？  
   - “異なる型を比較しようとするとどうなるか？”  
   - “ポインタか値か？”  
   - これらを論理的に考えながら小さな演習をこなすと、Go のインターフェースと型アサーションに慣れやすい。

### 3.7.3 ジェネリクス + インターフェース併用

- 例: 「何かしら比較演算 `>` を使う型に対して共通の `max` 関数を作る」  
  - `constraints.Ordered` (Go 標準の型制約) を使い、「文字列や数値であれば比較できる」形にする。  
  - `func Max[T constraints.Ordered](x, y T) T { ... }`  
  - こうすると `string`, `int`, `float64` の比較がまとめられる。  
- もし独自の型で `>` を使いたいならどうするか？  
  - その場合は `constraints.Ordered` ではなく、自前のインターフェースを作るか、あるいは一部の型に対してはオペレータが使えないので難しい。  
  - こうした点が「Go のジェネリクスは他言語と違い、演算が使える型が限定される仕組み」なのだという事例になる。

---

## 3.8 総合バグ修正演習

ここで、**複数の機能を組み合わせたバグ入りコード**を用意し、本章の内容を実践的に復習します。短期であっても、**バグ修正を繰り返す**プロセスを体験することで、より確実に知識を固められます。

**想定シナリオ**:  
- “あるパッケージに `Student` 構造体が定義されており、メソッド `GrowUp()` とインターフェース `Speaker` が存在する。さらに `func Filter[T any]` を導入しようとしているが…  
- コードがコンパイルエラーを起こしたり、実行時に意図と違う結果を返したりしている。”

（以下がバグ入りコード例。あまりにも長いので本書では付録やGitHubリポジトリに置き、「ここにバグが3つある」と提示する形がよいでしょう。）

### 3.7.1 修正箇所例 (考えるヒント)

1. **ポインタレシーバが必要なのに値レシーバにしている**  
   → “年齢を加算するメソッドが呼んでも反映されない”  
2. **インターフェースが要求するメソッド名が微妙に違う**  
   → “`Speak()` と書いているがインターフェースは `Says()` を要求している”  
3. **ジェネリック関数に型制約がなく、コンパイル時に比較演算が使えない**  
   → “`T` に `>` 演算子を使うけどエラーになる。 `constraints.Ordered` とか書く必要がある。”

**読者はこのコードを読み、謎解きをする**。「どこがおかしいか」「何を直すか」を論理的に考え、「修正して `go run` / `go build`」で動かせば成功、という流れを経験するわけです。これにより、本章で学んだ**関数や構造体、インターフェース、ジェネリクス**が総合的に駆使される状態になるでしょう。

---

## 3.8 まとめ

本章では、**関数、構造体、メソッド、可視性、インターフェース、ジェネリクス**といった、Go 言語の型や抽象化に関する主要機能を取り扱いました。特に「インターフェースとジェネリクス」は、Go 言語での設計をより柔軟かつ強力にする仕組みであり、初心者が短期でマスターするにはやや難易度が高い面もあるため、**適度にサンプルを試しつつ、自分なりのペースで理解**を深めてみてください。

### 3.8.1 ポイントの復習

1. **関数**  
   - プログラムを小さな処理単位で分割し、使い回しやすくする。  
   - 複数の戻り値 `(T, error)` でエラー処理をシンプルに行える。  
   - スコープルールを意識し、関数内の変数をむやみに外に出さない。

2. **構造体とメソッド**  
   - 複数フィールドを一塊で扱い、メソッドを持たせて振る舞いを一箇所にまとめる設計ができる。  
   - 値レシーバかポインタレシーバかは用途や更新の要否で選択。  
   - 大文字・小文字ルールで可視性（パッケージ外公開か否か）をコントロールする点も重要。

3. **インターフェース（オプション）**  
   - メソッドの集合を定義し、それを実装する型を「暗黙のimplements」で束ねる。  
   - 異なる型でも同じインターフェースを満たせば共通処理できる。  
   - `Speaker`, `io.Reader`, `io.Writer` などがよくある例。

4. **ジェネリクス（オプション）**  
   - Go 1.18 以降の新機能で、型パラメータを使った抽象化が可能に。  
   - コンパイル時に型を確定し、実行時のキャスト不要・安全性向上。  
   - 一方、制約の書き方や演算子の対応など学ぶ要素が多いため、本書では最低限の例のみに留めた。

### 3.8.2 今後につなげるために

- 次の章(第4章)では**エラー処理とテスト**を扱うので、関数や構造体の単位でテストを書く流れをぜひ体験してみてください。メソッドをテストしやすくなるのも、Go の強みの一つ。  
- 第5章以降で並行処理やデータ構造が出てきても、**関数と構造体を正しく活用し、インターフェースやジェネリクスで抽象化**すれば、大規模化にも耐えうる設計が可能になるはずです。

**本章が終わった段階で**、簡単なCLIツールや構造体を含むプログラムをきちんと組める下地ができたはずです。もし途中でわからない部分があれば、再度ミニ演習を試したり、バグ修正演習を繰り返して、**論理思考でコードの整合性をチェック**する習慣を付けると良いでしょう。

---

## 3.9 おわりに

ここまでで、**第3章（関数～構造体・メソッド + インターフェース + ジェネリクス）**をひととおり解説しました。

- **大枠の学習サイクル**  
  1. **関数で処理を分割** → 全体を見やすく  
  2. **構造体にフィールドとメソッドを結びつける** → データと振る舞いをセットで扱う  
  3. **大文字/小文字ルールで可視性を制御** → パッケージ外に公開するか否か  
  4. **インターフェース** → 実装の違う型を同じ操作で扱う抽象化  
  5. **ジェネリクス（型パラメータ）** → 複数の型に対して同一ロジックを汎用的に書ける

- **関数**と**構造体**は、Go 言語でプログラムを整理するための大切な要素です。特に「関数を分割して書く→テストがしやすくなる」という流れは、後の「第4章 エラー処理とテスト」でさらに効果が発揮されます。  
- **メソッド**によって、構造体にひも付いた処理をまとめることが可能になり、大規模開発における可読性・拡張性が向上します。  
- **可視性**については、「大文字で始まるかどうか」でパッケージ外への公開を制御できる点がユニークです。小文字の構造体やフィールドはパッケージ外から参照できません。Go 言語はあえてキーワードを使わず、大文字/小文字ルールで実装しているため、慣れないうちは戸惑うこともありますが、原理はシンプルです。
- **インターフェース**は、Go 言語の抽象化の要素であり、異なる型を共通処理できるようにするための仕組みです。
- **ジェネリクス**は、Go 1.18 以降の新機能であり、型パラメータを使った抽象化が可能になりました。型パラメータを使うことで、コンパイル時に型を確定し、実行時のキャスト不要・安全性向上が期待できます。ただし、制約の書き方や演算子の対応など学ぶ要素が多いため、初学者にはやや難易度が高いかもしれません。

- **読者の学習ステップ**  
  - 短期集中で一気に理解できなかったとしても、要点だけ押さえ、本書の後続の章（第4章「エラー処理とテスト」など）に進んで構いません。**本章で学んだ機能は、後々アプリを組む際に改めて振り返りながら使いこなしていく**イメージで大丈夫です。  
  - 興味やスキルに合わせて、**インターフェースやジェネリクスは後回し**にする選択肢もあります。「関数と構造体」だけでも十分にプログラムを進められます。どうしても抽象概念が難しく感じる人は、まず具体的なところで腕を慣らしてから、第3章後半に戻るやり方もありです。

**今後**、さらに**テスト**（第4章）や**並行処理**（第5章）と組み合わせると、関数やメソッド単位で容易にテストが書け、構造体やインターフェースを交えた大規模開発にも対応できる基盤が整います。**この章で身に付けた知識**が、Go 言語での開発スキルをワンランク引き上げる大きな一歩となるはずです。

---
