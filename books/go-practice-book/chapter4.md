---
title: "第4章：短期で身に付ける！エラー処理とテスト"
free: true
---

# 第4章 短期で身に付ける！エラー処理とテスト

## 4.1 はじめに

Go 言語でプログラムを書くうえで、**エラー処理**と**テストコード**は非常に重要な位置を占めます。これまでの章では関数や変数、制御構文などプログラムの“動く”部分に注目してきましたが、現実の開発では「動かなかった場合」「異常が起こった場合」をどう扱うかも同じくらい重要です。

- **エラー処理**:  
  不正な引数や外部システムの障害など、想定外の事態に適切に対処しないとプログラムの信頼性は下がります。Go 言語は「`error` インタフェース」と「エラーを値として返す」方針を中心に、シンプルなエラー処理モデルを提供しています。

- **テストコード**:  
  バグのないプログラムを完成させるには、なんども試験実行して検証する必要があります。Go 言語には標準で「`testing` パッケージ」があり、最小限のルールで気軽にテストを書けるのが特徴です。これにより、短期であっても確実に「プログラムが仕様通り動くか」確認できる土台が整います。

本章では、**エラー処理とテスト**を柱にして、Go 言語特有の「エラーを返す文化」や「`_test.go` ファイルによるテストの書き方」を学びましょう。少しでも慣れれば、Go の開発体験は一気に向上し、後々の大規模化にも耐えられる土台ができあがります。

---

## 4.2 Go 言語のエラー処理

### 4.2.1 エラーを「値」として返す文化

#### 4.2.1.1 なにをするか

Go 言語では、例外 (throw/catch) などの仕組みを基本的には使わず、**「エラーを戻り値として返す」**という方針を採っています。関数が失敗する可能性があるときは、**「(正常結果, error)」** のように複数の戻り値を返し、呼び出し元が「error が `nil` かどうか」をチェックして対処する、という流れが基本です。

```go
func doSomething(param int) (int, error) {
    if param < 0 {
        return 0, errors.New("negative param not allowed")
    }
    // 正常な計算処理
    return param * 2, nil
}

func main() {
    result, err := doSomething(-5)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)
}
```

このコードでは以下のポイントがあります。
- `doSomething` 関数は、正常なら `(結果, nil)` を返し、失敗なら `(0, エラーオブジェクト)` を返す。呼び出し元 `main` は `err != nil` でエラーをチェックし、あれば処理を中断する。
- 「例外をスローして呼び出し元に伝える」仕組みよりも、関数の呼び出しごとにエラーを明示的に扱うほうがシンプルでわかりやすい、という考え方に基づいている。Go では“errors are values”とよく言われ、エラー処理を各所で丁寧に書くことを促進する。
- `errors.New` や `fmt.Errorf` を使ってエラーメッセージを作る。後述するように「エラーラップ」や `%w` などもあるが、基本は `err != nil` チェックが中心。

#### 4.2.1.2 エラーを無視せずに書くスタイル

- Go でエラーを返す関数を呼び出した場合、通常はその戻り値の `err` をチェックして対処する必要があります。「`if err != nil { ... }`」というコードが頻出するため、最初は冗長に感じる人もいますが、**エラーを意識的に扱うことこそ、バグや不具合を早期に発見するカギ**とされています。
- エラーを無視したい場合にも明示的に「 `_ , _ = doSomething(...)`」などとして「本当に無視している」意思表示が必要です。デフォルトでは使っていない変数があるとコンパイラが警告するため、「うっかりエラー処理を忘れる」ミスが減ります。

---

### 4.2.2 `error` インタフェースの仕組み

#### 4.2.2.1 なにをするか

Go 言語には、エラーを表すための**`error` インタフェース**が定義されています。このインタフェースは非常にシンプルで、実態は「`Error() string` メソッドを持っている型」をエラーとして扱う、というルールです。

```go
type error interface {
    Error() string
}
```

- つまり、「`Error()` メソッドを実装した任意の型」が `error` として扱える、ということを意味します。標準ライブラリでも `errors.New("message")` は、`Error()` メソッドを備えた型を返す実装になっています。

#### 4.2.2.2 なぜこうなっているか

1. **自由度が高い**: ユーザが自作のエラー型を定義し、`Error()` メソッドをつけることで独自のエラー情報を持たせられる。  
2. **インタフェースによる抽象化**: コードの中では「エラーとは `error` インタフェース」という抽象に依存し、具体的にどんなエラー型であっても `err.Error()` でメッセージを得られる。

#### 4.2.2.3 どうやって使うか

- **通常のエラー生成**: `errors.New("message")` は、内部的に「`Error()` メソッドで "message" を返す型」を作り、`error` インタフェースとして返す。  
- **書式指定**: `fmt.Errorf("something happened: %v", cause)` も同様に `error` を返し、`Error()` メソッドを持つ匿名型を使っている。  
- **独自型**を作りたい場合

```go
type MyError struct {
    msg  string
    code int
}

func (e *MyError) Error() string {
    return fmt.Sprintf("MyError: %s (code=%d)", e.msg, e.code)
}
```

こうすれば、`&MyError{msg: "invalid input", code: 404}` を `error` として扱えるようになる。

---

### 4.2.3 `errors.New`, `fmt.Errorf`, エラーラップ

#### 4.2.3.1 `errors.New` / `fmt.Errorf`

Go 言語でよく使われるエラー生成関数は以下です。

- **`errors.New("message")`**  
  - シンプルに `"message"` を保持したエラーを返す。形式的には「最小限の情報しか持たない `error`」  
- **`fmt.Errorf("format string", args...)`**  
  - `Printf` と同じ書式指定でエラーメッセージを生成し、`error` を返す。  
  - 例: `fmt.Errorf("cannot open file %s: %v", filename, cause)`

#### 4.2.3.2 エラーラップ (`%w`)

Go 1.13 以降では、`fmt.Errorf` で `"%w"` という書式を使うと、元のエラーを**“包み込んだ”**新しいエラー(ラップエラー)を作れます。つまり、**“原因となるエラー”** を内部に保持しつつ、新しいメッセージで包む形です。これにより、呼び出し元が `errors.Is` や `errors.As` で原因エラーを判定しやすくなります。

```go
if err != nil {
    return fmt.Errorf("failed to doSomething: %w", err)
}
```

- **こう書くと**、上位レイヤーで `errors.Unwrap(newErr)` すれば `err` を取り出せる。  
- **なぜ必要か**: 「どこでエラーが起こったか」という情報を積み重ねながら上位に伝えたい場合、メッセージを付け足すだけでなく、元のエラーを保持し続けることが望ましいから。

---

## 4.3 テストの書き方 (`testing` パッケージ)

Go 言語には、標準で**“テストを書くための仕組み”**が最初から備わっています。特別なフレームワークを導入しなくても、**`go test`** コマンドを使うだけでテストのビルドと実行を行えます。

### 4.3.1 `_test.go` ファイルのルール

#### 4.3.1.1 なにをするか

- Go では、テストコードを「`ファイル名_test.go`」という形式で用意し、その中に**「Test◯◯◯(t *testing.T)」** という関数を書くと、`go test` で自動的にテストが走る仕組みになっています。

#### 4.3.1.2 具体例

```go
// mathutil_test.go
package mathutil

import "testing"

func TestAdd(t *testing.T) {
    res := Add(2, 3)
    if res != 5 {
        t.Errorf("Add(2,3) = %v; want 5", res)
    }
}
```

- **ファイル名**: `mathutil_test.go`  
- **パッケージ名**: 通常は同じパッケージ名を使うか、 `package mathutil_test` として書き分けるかどちらでも構いません。  
- **テスト関数の名前**: `TestAdd` のように、**`Test` で始まる**関数を `func (t *testing.T)` の形式で定義する。Go のテストプログラムが自動的にこの関数を探して実行します。

#### 4.3.1.3 なぜそうするか

- **統一ルールでシンプルに**  
  他の多くの言語ではテストフレームワークを別途導入し、設定ファイルやクラス継承を用意することが多いですが、Go では「`_test.go` ファイル」「`Test◯◯(t *testing.T)`」というだけで完結するので、学習コストが低い。  
- **自動化しやすい**  
  `go test` コマンドを叩くだけで同じパッケージ中のすべての `_test.go` をコンパイル・実行するため、大量のテストも簡単に回せる。

---

### 4.3.2 テーブルドリブンテスト

小さなテストを書く場合でも、**“パターンごとにコードを重複”**させるのではなく、一つの関数内で複数のケースをまとめる「テーブルドリブンテスト」という書き方がよく使われます。

#### 4.3.2.1 なにをするか

「テストしたい入力と期待する出力」を一覧（テーブル）にし、ひとつのループで全ケースを実行して結果を確認します。こうすれば**テストコードの重複**を減らし、追加のケースを増やしやすい利点があります。

```go
func TestAdd(t *testing.T) {
    cases := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"two positives", 2, 3, 5},
        {"zero and positive", 0, 5, 5},
        {"negative and positive", -1, 2, 1},
    }

    for _, c := range cases {
        t.Run(c.name, func(t *testing.T) {
            res := Add(c.a, c.b)
            if res != c.expected {
                t.Errorf("Add(%d, %d) = %d; want %d", c.a, c.b, res, c.expected)
            }
        })
    }
}
```

- `cases` というスライスに複数のテストケースをまとめ、`for` ループ内で `t.Run(c.name, ...)` を呼ぶことで、ケースごとにサブテストが実行される。  
- ケース数が多いときにコードの重複を大幅に減らせるし、テスト結果を“どのケースが成功/失敗したか”という単位で表示できる。  
- `t.Run(サブテスト名, func(t *testing.T) { ... })` という書き方でサブテストを定義し、ケースごとの検証を行う。

---

## 4.4 章末課題

### 4.4.1 これまでの小さい関数に対してテストを書いてみよう

前の章で作ったいくつかの小さな関数（たとえば、加算関数や文字列操作関数など）があれば、それらに対して**テストコード**を作成し、**エラー処理を含めた挙動**をチェックする課題に挑戦してみてください。具体的には以下の手順が考えられます。

1. **関数を確認**  
   「どういう引数を与えればどういう結果が欲しいのか？ どんな異常ケースがありえるか？」と仕様を洗い出す。  
2. **_test.go ファイル作成**  
   ファイル名を「`xxx_test.go`」として、パッケージを同じにするか `_test` をつけるか選ぶ。  
3. **Test◯◯関数を書く**  
   それぞれの関数について「正常系の入力」と「異常系の入力」を最低 1 ケースずつ想定し、`if result != expected { t.Errorf(...) }` のように検証。  
4. **テーブルドリブンテストに挑戦**  
   ケースが複数あるなら、スライスにまとめてループを回す書き方を試してみる。  
5. **`go test -v` 実行**  
   テストの結果がすべて PASS になれば成功。仮に FAIL があっても、その理由を確認してコードまたはテストのどちらを修正するか判断する。

この課題を通じて、**「エラーが返る関数をどうテストするか？」** も体験してください。たとえば、「引数が負数のときは `error` を返す関数」であれば「**負数を与えたら本当にエラーが返るか**」「エラーは `nil` ではないか」などを確認するテストを書き、意図どおり挙動するかを検証します。

---

### 4.4.2 バグ入りコード演習：失敗テストが含まれる → 修正して PASS させる

もう一つの課題として、**「故意に失敗するテストが含まれるプロジェクト」**を用意し、あなたがその原因を見つけ出して修正する演習を行ってください。

- **プロジェクト構成例**:  
  ```txt
  myproj/
    - calc.go         (いくつかの計算関数)
    - calc_test.go    (テストコード: そのうち2ケースにバグが仕込まれている)
  ```
- **課題内容**: `go test` すると FAIL するテストがある。その原因は関数のロジックミスか、テストコードの期待値設定ミスか、あるいはエラー処理の漏れかもしれない。  
- **修正方法**:  
  1. `go test -v` して失敗メッセージを読み、どの行・どのケースがエラーかを確認。  
  2. ソースコードとテストコードを読み比べ、想定仕様との食い違いを特定する。  
  3. コード (またはテスト) を修正し、再度 `go test`。 PASS になるか確認する。

**この演習を通じて**、「テスト失敗の原因をどのように探るか」「テストを修正すべきか、関数の実装を修正すべきか」を考える力が身につきます。短期でも実施すればバグ修正の実践的ノウハウを得られるでしょう。

---

## 4.5 さらに知っておくと便利なトピック

### 4.5.1 エラーの比較・判定：`errors.Is` / `errors.As`

Go 1.13 以降、「エラーのラップ」を `%w` で行った場合、**元のエラーを含むかどうかを判定**できる関数が用意されています。

- **`errors.Is(wrapperErr, targetErr)`**  
  - `wrapperErr` がラップしているエラーの中に `targetErr` と同じ型・値が含まれていれば `true`。  
  - たとえば、`fmt.Errorf("additional info: %w", originalErr)` で作ったエラーが `originalErr` を含むかを確かめられる。  
- **`errors.As(err, &someType)`**  
  - ラップされたエラーの連鎖の中に、`someType` のエラーが含まれていればポインタに代入して `true` を返す。  
  - 例: `errors.As(err, &myCustomErr)` として、実際にその型のエラーかどうか判定する。

エラーをラップして上位に伝える際、**下位の原因エラーに応じたハンドリングが必要**なケース(特定のエラー型だけ再試行など)で、この機能が役立ちます。短期学習で使う機会は少ないかもしれませんが、実務では非常に重要です。

---

### 4.5.2 テスト補助関数：`t.Helper()`, `t.Run()`, ベンチマーク

1. **`t.Helper()`**  
   - テスト内で「エラーメッセージを出力する関数」があるとき、そこの行番号ではなく、呼び出し元の行番号が表示されるようにしたい場合に `t.Helper()` を呼んでおく。これによりデバッグしやすくなる。  
2. **`t.Run(subtestName, func(t *testing.T){...})`**  
   - テーブルドリブンテストなどで、ケース名を付けてサブテストを行うと、細かい成功/失敗を把握しやすい。  
3. **ベンチマーク (`BenchmarkXxx`)**  
   - `_test.go` ファイルに `func BenchmarkAdd(b *testing.B)` のような関数を書くと、`go test -bench=.` でパフォーマンス測定を行える。短期学習では優先度が下がるが、大規模化したときに役立つので覚えておくと良い。

---

## 4.6 まとめ

### 4.6.1 本章のポイント整理

1. **Go のエラー処理**  
   - 関数がエラーを返す場合、「(結果, error)」 という形で返すのが基本。  
   - 呼び出し側は `if err != nil { ... }` でエラーをチェックし、適切に対処する。隠さない、無視しない。  
   - `errors.New` / `fmt.Errorf` でメッセージ付きエラーを生成する。`%w` によるエラーラップも可能。

2. **テストの書き方**  
   - `func Test◯◯(t *testing.T)` を `_test.go` ファイルに書き、`go test` で自動実行。  
   - 失敗時は `t.Errorf(...)` や `t.Fatal(...)` で報告する。  
   - テーブルドリブンテストを使えば複数のケースを一括で記述でき、管理しやすい。

3. **章末課題**  
   - 既存の小さい関数に対してテストを書き、「正常系」と「異常系」で意図通り動くか確認する。  
   - バグ入りコードを修正し、テストで PASS させる。このプロセスを何度も体験すれば、バグ修正のスキルが向上し、Go でのエラー処理とテストの連携がわかりやすくなる。

### 4.6.2 次の展開

- **第5章**（並行処理）でゴルーチンやチャネルを学ぶ際にも、エラーとテストは常につきまといます。特に並行プログラムはバグが起きやすいため、テストをしっかり書くことが大切です。  
- **第6章**（小規模プロジェクト）では、CLI アプリを開発しながらエラー処理とテストを実践します。ユーザ入力が不正な場合やファイル操作に失敗した場合など、エラーが起こり得る状況を設計し、テストで確認する流れが登場します。  

### 4.6.3 最後に

本章で解説した「エラー処理」と「テストコード」は、**短期でも確実に身につけたい“Go 開発の基本素養”**です。エラーを返す関数を当たり前に書き、戻ってきたエラーを当たり前にハンドリングする。この積み重ねで、プログラムの信頼性が向上し、あとから読む人（自分含む）が**「どこでエラーが起きる可能性があって、そのときどう処理するのか」**をすぐに理解できるようになります。

- **エラーを無視しない文化**  
  Go 言語はコンパイラが「使われていない変数」を警告するため、エラーを放置できません。これにより、「エラー処理をうっかり忘れる」リスクを減らしているのが大きな特徴です。  
- **テストを活用して安全性を高める**  
  短期であってもテストを書けば、致命的なバグを見逃しにくくなります。意外と簡単に書けるので、行数は増えても価値は十分にあります。  
- **バグ入り演習を通じた実践**  
  小さな関数でも、バグを仕込んでテストを失敗させ、修正してパスさせる体験を積むと、本当にバグと遭遇したときに怖くなくなります。実務でも「テストが落ちる → ログやエラーメッセージを見て修正する」を繰り返すため、この練習は有意義です。

エラー処理とテストに慣れれば、Go で作るプログラムの堅牢性・信頼性が一気に高まり、開発サイクルもスムーズに回るようになります。ぜひ一度試して、「テストコードを走らせる → エラーを修正 → 再度テストを走らせる」という一連の流れを体感してみてください。
