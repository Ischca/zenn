# 解答

---

## 1. 選択式問題の解答

### 1-1. スライスの基礎

1. **解答**: (C)  
   - `var s []int` と宣言しただけでは `s` は `nil` だが、Go では `append(s, 10)` のように使えば自動で領域が割り当てられ、問題なく要素を追加できる。  
   - (B) は「エラーになる」とあるが、実際にはコンパイル/実行エラーは起きず、append で対応可能。  
   - (A) は固定長ではなく、len/capを指定しないと要素数3にはならない。

2. **解答**: (A)  
   - `append` を呼ぶと長さ(len)が増え、容量(cap)が足りない場合は再確保される。  
   - (B)「capが変わらない」は誤り。 (C) は一部正しい部分もあるが、選択肢としては「appendは常に新しいスライスを返すわけではない」→ 実質スライスの別実体が返る場合もあるが回答として混乱を招く。**問題の文脈では(A)が最適解**。

### 1-2. スライスの参照渡し

3. **解答**: (B)  
   - スライスは「内部で同じ配列を共有」するため、関数内で `arr[0] = 999` のように変更すると呼び出し元も変更される。  
   - (A) はスライス丸ごとコピーではないので誤り。(C) も誤り。

4. **解答**: (B)  
   - `sub := nums[1:4]` は `nums` と同じ配列を参照しているので、`sub` の要素を書き換えると `nums` 側にも影響が反映される。  
   - (A) は独立コピーではなく、(C) コンパイルエラーも起きない。

### 1-3. マップの基礎

5. **解答**: (B)  
   - `var scores map[string]int` は `nil` マップであり、`scores["Alice"] = 80` と代入すると**パニック**が発生。  
   - `make(map[string]int)` していれば (A) になるが、ここではしていないので書き込み不可。 (C) は何も起きない、というわけではなく実際には runtimeエラーが起きる。

6. **解答**: (B)  
   - `delete(mymap, "X")` でキー "X" が削除され、残るのは "Y"。よって `map[Y:20]`。  
   - (A) は削除前の状態、(C) は逆に "Y" が消えているので誤り。

### 1-4. マップの順序保証

7. **解答**: (C)  
   - Go のマップはキーの追加順や文字列順を保持しない。反復順序は保証されず、実行環境や要素の変化によって異なることがある。  
   - (A), (B) はどちらも誤り。

---

## 2. 穴埋め式問題の解答

### 2-1. スライスの操作

```go
func main() {
    var nums []int
    nums = (A)(nums, 10)
    nums = (A)(nums, 20)
    nums = (A)(nums, 30)

    fmt.Println("len=", len(nums), "cap=", (B)(nums))
}
```

- **(A)** → `append`  
- **(B)** → `cap`

完成形 (例)：
```go
func main() {
    var nums []int
    nums = append(nums, 10)
    nums = append(nums, 20)
    nums = append(nums, 30)

    fmt.Println("len=", len(nums), "cap=", cap(nums))
}
```

---

### 2-2. スライスから部分区間を取り出す

```go
data := []int{5,10,15,20,25,30}
sub := data[(C):(D)]
fmt.Println(sub)
```

- 「`10,15,20` を取り出す」には **`data[1:4]`** の範囲が `[1,2,3]` → `10,15,20`。  
  - **(C)** → `1`  
  - **(D)** → `4`

---

### 2-3. マップへの書き込みと検索

```go
func mapDemo() {
    (E) := make(map[string]int)
    (E)["Alice"] = 80

    score, ok := (E)["Bob"]
    if !ok {
        fmt.Println("Bob not found")
    } else {
        fmt.Println("Bob:", score)
    }
}
```

- 同じ変数名で埋める必要あり。例えば `(E) = "grades"`。

完成例：
```go
func mapDemo() {
    grades := make(map[string]int)
    grades["Alice"] = 80

    score, ok := grades["Bob"]
    if !ok {
        fmt.Println("Bob not found")
    } else {
        fmt.Println("Bob:", score)
    }
}
```

---

# まとめ

- **スライスとマップ**の基礎は、「nil状態」「appendで伸びるか」「容量(cap)」などの細かな挙動を理解することが大切。  
- **穴埋め問題**を通じて、実際のコード上でどこに `append` と書くか、どこで `cap` を呼ぶか、`make(map[...])` を使わないとパニックが起きる点などを復習できた。  
- この解答を照らし合わせて**間違いがあれば復習**し、**章末課題（電話帳/在庫管理アプリなど）**にスムーズに進んでみてください。