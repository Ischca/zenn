---
title: "総合ミニテスト：全範囲復習（解答）"
free: true
---

# 総合ミニテスト 解答編（Level 1～3）

## Level 1（基礎確認）

### Q1 (選択)
**問題**: Go 言語で「実行可能プログラム」を書くときに必須なのは？  
**選択肢**

1. **「ファイル名を `main.go` にしておく」**  
   - これは Go で実行ファイルを作るときに慣習的に多い例ですが、「必須」ではありません。  

2. **「`package main` と `func main()` を定義する」**  
   - Go で実行可能なバイナリをビルドするためには、最低限 `main` パッケージと `main()` 関数が必要。  

3. **「メイン関数の中で必ず何らかの処理 (print文など) を含める」**  
   - 実際のプログラムでは通常何かしらの処理を書くでしょうが、**空の `main()`** でもビルド自体は可能なので「必須」ではありません。  

4. **「プロジェクトに `import "fmt"` を含め、実行時に出力を行う」**  
   - 多くのサンプルで `fmt` を用いるものの、出力を行わないプログラムもコンパイル・実行できます。必須ではありません。

**解答**: **(2) 「`package main` と `func main()` を定義する」**  

**解説**:
  - Go では、**実行形式**のプログラム（`go build` や `go run` で起動できるバイナリ）を作る際、\**必ず** `package main` と `func main()`** のセットが必要となります。  
  - (1), (3), (4) はいずれも「一般的にそう書くことが多い」「便利な書き方」といったレベルの話であり、**“必須条件”**ではありません。たとえばファイル名が `main.go` でなくても、空の `main()` でも、`fmt` を使わずともバイナリは生成できます。

---

### Q2 (選択)
**問題**: 次のコードについて正しい説明は？
```go
var name string
name = 123
fmt.Println(name)
```

1. **Go では、変数をいったん宣言すれば、同じスコープ内で何度でも再代入が可能**  
2. **このコードはコンパイルエラーになる。`name` が `string` なのに `123` (整数) を代入しており、型が不一致だから**  
3. **`fmt.Println` で複数の引数を与えれば、スペース区切りで表示されるので、もし別の変数を足しても簡単に出力できる**  
4. **`var name = 123` と書けば、暗黙の型推論で `name` が int となり、エラーなく `123` と出力するプログラムになる**

**解答**: **(2)**

**解説**:
- **(2) が正解**  
  - `name` は `string` 型で宣言されているため、整数リテラル `123` を代入すると**型不一致**でコンパイルエラー。Go は静的型付け言語なので、暗黙変換は行われません。
- (1) **再代入は可能**  
  - 部分的には正しいが、このコードの場合は「型が不一致」なのでエラーになる点の説明になっていません。
- (3) **`fmt.Println` で複数引数を与えるとスペース区切りで表示する**  
  - これ自体は Go の正しい特徴ですが、**本問の挙動（コンパイルエラー）**とは関係ありません。
- (4) **`var name = 123` と書けば…**  
  - 確かにそう書けば `name` が int になりエラーは出なくなるでしょうが、「今のコードがどうなるか？」の説明ではありません。本問に直接の回答にならない。

---

### Q3 (穴埋め)
**問題**: 以下のコードで `x` に `10` を初期値として与えたい。ただし、Go の**短縮宣言** (`:=`) を使う。空欄を埋めなさい。
```go
func main() {
    _____
    fmt.Println(x) // 10
}
```

**解答**: `x := 10`

**解説**:
Go でローカル変数を宣言・初期化する最も手短な方法が `:=` です。**短縮宣言**とも呼ばれ、「変数宣言 + 型推論 + 初期化」を一度に行う仕組みとして使われます。例えば `x := 10` と書けば、Go は `x` を `int` 型と推論し、値を 10 で初期化します。また、短縮宣言は関数スコープでのみ使え、Go の変数宣言をスッキリ書ける利点があります。一方、グローバルスコープでは `:=` は使えない点にも注意が必要です。

- **他の書き方**:  
  1. `var x = 10` → 明示的に変数宣言し、型推論で 10 (int) と認識  
  2. `var x int; x = 10` → 2行に分ける。初期化の手順が明確になるがやや冗長  
  3. `x = 10` は「既に宣言された x に代入する」形で、新規宣言ではない

---

### Q4 (判断)
**問題**: Go で `const` に一度値を代入したら、その後変更できる？  
**解答**: **(B)**（変更不可）

**解説**:- `const` は**再代入不可能**です。コンパイル時に値が固定されるため、後から `constName = newValue` のように書くとエラーになります。変数なら変更できるが、定数はできません。

---

### Q5 (選択)
**問題**: Go の `if` 文に関する次の説明のうち、**最も適切なもの**はどれでしょうか。

1. **Go の `if` 文は、条件を `( )` で囲む必要があり、さらに一文だけのブロックなら `{ }` を省略できる**  
2. **Go の `if` 文では初期化文を書くことができるが、その場合は `;` で区切る必要がある**  
3. **Go の `if` 文では、`0` は `false`、それ以外の数値は `true` として扱われる**  
4. **Go の `if` 文では `( )` は必須ではなく、むしろ省略するのが一般的で、ブロックの括弧 `{ }` は常に必要である**

**解答**: **(4)**

**解説**:- **(4) が正解**: Go の公式スタイルでは `if x > 0 { ... }` のように**丸カッコを付けないのが一般的**です。一方で `{ }` は必須なので**ワンライナー**にして省略はできません。
- (1) は C/Java などの影響でそう思いがちですが、Go では `if` の条件式は `()` で囲む必要はありません。
- (2) Go言語の`if`文では初期化文を書くことができますが、`;` で区切る必要はありません。
- (3) 数値をブールに暗黙変換する仕組みは Go にありません。たとえば`if 1 {}` はコンパイルエラーです。

---

### Q6 (単純記述)
**問題**: `for i := 0; i < 5; i++ { ... }` は何回ループするか？  
**解答**: **5回**

**解説**:- `i` が 0 から始まり `i < 5` の間ループを回す → `i=0,1,2,3,4` の計5回。

---

### Q7 (穴埋め: switch)
**問題**: 
```go
switch x {
( A ) 1:
    fmt.Println("one")
( B ) 2:
    fmt.Println("two")
( C ):
    fmt.Println("other")
}
```
**解答例**:
- (A) → `case`
- (B) → `case`
- (C) → `default:`

完成:
```go
switch x {
case 1:
    fmt.Println("one")
case 2:
    fmt.Println("two")
default:
    fmt.Println("other")
}
```

- **解説**: Go の switch で case に当てはまらなければ `default` が実行される。
- `switch x { case 1: ... case 2: ... default: ... }` が典型的な形。
- `default:` 節は「上記以外の場合」という意味で、省略可能ですが、一般的には書いたほうが安全です。

---

### Q8 (選択)
**問題**: Go の整数型 `int` は、プラットフォームによって32ビット or 64ビットになる可能性があるが、その違いに一般的にどう対処するのが正しいでしょうか？

1. `int` は環境依存で32か64か決まるが、通常の数値演算では問題になりにくいのでそのまま使うことが多い
2. Go のコンパイラは整数演算をすべて 64 ビット幅として振る舞う  
3. 実行時に `int` のビット幅が動的に切り替わり、プログラム内でサイズが変化  
4. 複数アーキテクチャ対応のため、`int` はメモリ配置が2バイト刻みになる

**解答**: **(1)**

**解説**:
**なぜ `int` は環境依存？**

Go の仕様では、`int` はそのプラットフォーム（アーキテクチャと OS 組み合わせ）に応じて**32ビット幅または64ビット幅**になると定義されています。これは C 言語や他の静的型付け言語にも見られるアプローチで、

- **32ビット環境**では `int` が 32ビット（最大値約 2^31-1）  
- **64ビット環境**では `int` が 64ビット（最大値約 2^63-1）

となるため、ソースコード上は単に `int` と書いていても、ビルドするターゲットプラットフォーム次第でビット幅が変わる仕様です。

**(1) が正解の理由**

> **「`int` は環境依存で32か64か決まるが、通常の数値演算では問題になりにくいのでそのまま使うことが多い」**

- **現場での慣習**: Go の公式スタイルや一般的な Go コードでは、特に制限がない限り `int` を使うのが慣例です。典型的な業務ロジックやアルゴリズム実装では 2^31 や 2^63 の上限に引っかかるようなケースが少なく、当面 `int` で不足しないことが多いです。  
- **トラブルが少ない**: もし 64ビット以上の整数が必要な場面はごく限られ、しかもそのときは `int64` や `big.Int`(任意精度) を選ぶことが明確になります。逆にほとんどの 64ビット環境では `int` が 64ビットなので、数値演算のオーバーフローに困るシーンは稀です。

**他の選択肢の解説**

1. **(2)「Go のコンパイラは常に 64 ビット演算を行う」**  
   - 一見「64ビット環境ならそうかも」と思えますが、Go は 32ビット環境上では 32ビット幅として動作しますし、コンパイラが一律で 64ビット演算を使うわけではありません。  
   - 実装によっては命令セットや最適化の違いがあるが、「常に64ビット演算になる」わけではないので本問の最適解にはならない。

2. **(3)「実行時に `int` のビット幅が動的に切り替えられる」**  
   - Go の言語仕様で、ビルド時点でターゲット環境が決まります。実行中に動的にビット幅が変わるわけではありません。  
   - これは動的型付け言語であってもないような挙動。誤解を招く選択肢です。

3. **(4)「メモリ配置が2バイト刻みになるよう自動調整される」**  
   - これは他の言語や特定のアーキテクチャにおける特殊知識と混同している例。Go が `int` の配置を2バイト単位に調整するような仕組みは定義されていません。  
   - Go は基本的に 4バイト or 8バイト（32or64bit）幅が標準となるだけです。

**いつ `int32` / `int64` を使う？**

- **特殊要件**があるときに明示的に使います。例えばファイルサイズやタイムスタンプなど、64ビット固定で管理したい場合は `int64`。  
- API レベルで 32ビット確定のデータを扱う場合は `int32` を使うと混乱を回避できます。

---

### Q9 (穴埋め: 単答)
**問題**:
Go 言語は**（____）型付け言語**と呼ばれる。  

**解答**: **静的型付け**（「静的型付け言語」）

**解説**:
Go は**静的型付け**言語です。コンパイル時に型チェックが行われ、型不一致があればビルド時にエラーとなります。
ただし、インターフェースや `any` を使って「動的に型を判定する」仕組み（=ある程度の動的要素）もあり得ますが、基本は静的型付け。  
- **動的型付け** はJavaScriptやPythonのように、変数宣言時に型を固定せず実行時に判定するやり方。Go とは異なります。

---

### Q10 (判断)
**問題**:
Go では「型定義」と「型エイリアス」という2つの方法で新しい型名を作れます。もし “`MyInt` を `int` として**別物の新しい型**にしたい（`int` と互換性を持たない）” 場合、どの書き方が正しいでしょうか？

(1) `type MyInt = int`  
(2) `type MyInt int`  
(3) `type MyInt int = new`  
(4) `MyInt := int`

**解答**: **(2)**

**解説**:
Go では “ `type MyInt int` ” と書くと「新たな型 `MyInt` を定義し、内部表現は `int` だが別物」と認識され、`MyInt` と `int` は代入などで直接は互換しません。たとえば次のコードで確認できます:
```go
package main

import "fmt"

type MyInt int

func main() {
    var x MyInt = 100
    var y int = 100
    // y = x // コンパイルエラー: 型が異なる
    fmt.Println(x) // 100
}
```

一方、もし “ `type MyInt = int` ” と書いた場合は「エイリアス」であり、`MyInt` と `int` は実質同じ型扱いです。メソッドを追加して独自の振る舞いをもたせることもできません。
「型定義 (`type T S`)」と「型エイリアス (`type T = S`)」の区別は Go の基礎的かつ重要な概念です。独自型を作りたい時は定義を、既存型に別名を付けるだけならエイリアスを使います。

**他の選択肢**:
- (1) `type MyInt = int` は「型エイリアス」であり、新しい型ではなく `int` と同一視されます。そのため、エラーにはなりませんが、`MyInt` と `int` は同じ型として扱われます。
- (3) `type MyInt int = new` のような文法は Go にありません。  
- (4) `MyInt := int` は「短縮宣言」風の書き方であり、型定義になりません。変数宣言とも違って構文エラーです。

---

## Level 2（中程度）

### Q11 (選択: スライスの len と cap)
**問題**:
```go
s := make([]int, 3, 5)
```
`len(s)` と `cap(s)` の値は？

**解答**: **(1) len=3, cap=5**

**解説**

**`len` (長さ) と `cap` (容量)**
- **長さ (`len`)**: 現在アクセス可能な要素数  
- **容量 (`cap`)**: スライスが再割り当てなしに使える最大要素数  

スライスは内部で「ポインタ・長さ・容量」を持ち、長さが `len`、容量が `cap` に対応します。初期生成時点で `len` が 3 ならインデックス `0,1,2` が使え、容量 5 は「あと 2 個ぶん要素を追加しても新たにメモリを割り当てなくて済む」という意味です。

**`make([]int, 3, 5)` の仕組み**
Go の `make` 関数は、**スライス/マップ/チャネル**といった参照型を生成する際に用いられます。  
```go
make([]T, length, capacity)
```
- 第2引数 (**length**) → スライスの初期長さ  
- 第3引数 (**capacity**) → スライスの容量 (任意指定しない場合は length = capacity)

本例 `make([]int, 3, 5)` は「長さ3、容量5」のスライスを作るため、

- `len(s) = 3`
- `cap(s) = 5`

という設定になります。

**選択肢の解説**
- **(1)** 逆に書いており誤り (`len=5, cap=3` はここでは正しくない)。  
- **(2)** 正解。`len=3, cap=5`。  
- **(3)** 長さ・容量は宣言直後に明確に定まるので「不定」ではありません。  
- **(4)** `make([]int, 3, 5)` は正しい文法でエラーになりません。


---

### Q12 (穴埋め)
**問題**: スライスに要素を追加する関数。  
```go
nums := []int{}
nums = _____(nums, 10)
nums = _____(nums, 20)
```
**解答**: **append**

```go
nums = append(nums, 10)
nums = append(nums, 20)
```

**解説**:- `append(slice, elem)` は Go のビルトイン関数で、スライス末尾に要素を追加し、新しいスライスを返す。

---

### Q13 (選択: マップの削除)
**問題**: Go のマップ `map[string]int` で、あるキー `"Alice"` を削除するにはどう書くか。

1. **`delete(m, "Alice")` を呼び出すと指定キーごとエントリを取り除ける**  
2. `m["Alice"] = 0` と代入すれば、Go ランタイムが“0 値”を検出し自動的にマップからキーを排除する  
3. `m = make(map[string]int)` と再生成するのが一般的で、不要キーだけ消す操作は無駄が多いので推奨されない  
4. Go のマップはイミュータブル（不変）構造なので、削除には一旦新しいマップを作って必要なキーのみコピーする  

**解答**: **(1)**

---

**解説**

**なぜ (1) が正解か**

- Go には**ビルトイン関数** `delete(マップ, キー)` があり、**そのキーに対応する要素を完全に取り除く**機能を担います。  
- 具体例:  
  ```go
  m := map[string]int{"Alice": 100, "Bob": 200}
  delete(m, "Alice")
  // これで "Alice" キーは完全に消え、 m["Alice"] は存在しなくなる
  ```
- この操作により `m` の中から `"Alice"` が確実に削除され、後で `m["Alice"]` を読み込むと要素が存在しないと判定されます。

**他の選択肢の解説**

1. **(1) `delete(m, "Alice")`**  
   - **本問の正解**。Go で部分的にキーを消す場合の正式な方法。

2. **(2) `m["Alice"] = 0` と代入すれば…**  
   - 値を `0` にするだけで、キー自体は残ります。Go には「0 値を見て自動削除」する仕組みがありません。  
   - したがってこのやり方は、削除ではなく「キーの値を 0 に上書き」するだけです。

3. **(3) `m = make(map[string]int)` と再生成…**  
   - これを行うと **すべて** のキーが消えてしまうため、「特定のキーだけを取り除く」目的にそぐいません。  
   - あるキーだけを消したいなら `delete(m, "Alice")` が最適。  
   - 場合によっては「全削除」が必要なら再生成も一案ですが、「不要キーだけ消す操作が無駄が多い」というのは誤解です。

4. **(4) Go のマップはイミュータブルなので…**  
   - Go のマップは**可変（ミュータブル）**です。イミュータブルではありません。  
   - 一時的に新しいマップを作り直す方法も可能ですが、まったく必須ではありません。

**補足: `delete` の使い方と注意点**

- **書式**: `delete(マップ, キー)`  
- **キーが存在しない場合**: 何も起きずエラーにもなりません。つまり “安全に” 呼べます。  
- **キーが存在する場合**: そのエントリが取り除かれます。  
- **マップが nil の場合**: `delete(nil, "Alice")` はランタイムエラーにはならず、単に無視されます。  
  - とはいえ、nil マップは通常読み書きがエラーになる点に注意が必要です。

---

### Q14 (選択: nil マップ)
**問題**: 次のマップ宣言で、`myMap` が `nil` になるケースはどれか。

1. `var myMap map[string]int` だけで初期化しないと、nil マップになる  
2. `myMap = make(map[string]int)` と書いても、最初の代入時に内部的に nil チェックが行われて実体化されないことがある  
3. Go では `map[string]int{}` を書いてもマップ本体が遅延評価されるので、アクセスするまで実態がnilとして扱われる  
4. 宣言のしかたに関係なく、Go のマップはどのタイミングでも書き込み可能なので nil チェックは不要  

**解答**: **(1)**

**解説**
**nil マップの宣言**
- **(1) が正解**: Go では `var myMap map[string]int` と宣言した場合、**初期化を行わない**ため内部的には `nil` が割り当てられます。  
  - たとえば以下のように書いた場合:
    ```go
    var myMap map[string]int
    // myMap は nil
    fmt.Println(myMap == nil) // true
    ```
  - この状態で `myMap["Alice"] = 100` のように書くと、**ランタイムエラー**（panic）が起きます。

**他の選択肢**

1. **`myMap = make(map[string]int)`**  
   - `make(...)` によりマップが**実体化**されるので、nil ではなく空のマップになる。`myMap["Alice"] = 100` も正常に動作します。

2. **`map[string]int{}`**  
   - これも**リテラルによる初期化**であり、nil ではなく空のマップ（キーなし）を作ります。したがって書き込み可能です。

3. **マップはどのタイミングでも書き込み可能なので nil チェック不要**  
   - Go のマップは可変ですが、**nil のまま書き込むとエラー**になります。必ず `make` やリテラル生成などで実体化が必要です。

**nil マップに関する注意点**

- **nil のマップ**と**空のマップ**は見た目は同じようにキーが存在しない状態でも大きく異なり、nil マップに書き込みしようとすると `panic` が発生します。  
- 一方、nil マップを **読み込み**（例えば `val := myMap["Alice"]`）する行為はエラーなく行え、ゼロ値（intなら0）が返ります。このあたりが “書き込みはエラー、読み込みはゼロ値を返す” という挙動として混乱しやすいポイントです。

---

### Q15 (選択: 複数戻り値 `(int, error)` の理由)
**問題**: 以下の関数宣言において、戻り値が `(int, error)` になっているのはなぜか。

```go
func doSomething(a, b int) (int, error) {
    // 中略
}
```

1. Go では複数の戻り値を返せるため、正常結果とエラーを同時に返すのがよくあるスタイル  
2. `error` は暗黙的に `int` と互換性があり、0 ならエラー無し、負数なら警告、正数なら致命的エラーを表す  
3. カンマ区切りで書く戻り値は、実は引数として渡される仕組みであり、最後にまとめて処理される  
4. Go ではエラーを返す場合でも `panic` が実行されるため、実質 `(int, error)` はダミー定義に近い  

**解答**: **(1)**  
**解説**
1. **Go は複数の戻り値を返すことができる**  
   - Go 言語は他言語のように「戻り値は1つだけ」ではなく、`(T, error)` のように複数の値を返せるのが特徴です。これにより正常結果 (`int` など) とエラー (`error`) をペアで返す習慣が広く浸透しています。  
   - これが**本問の答え**。「よくあるスタイル」というのは、Go の**エラーを例外としてスローせず、戻り値として明示する**という設計思想が背景にあります。

2. **(2) `error` と `int` が互換性を持つ**  
   - こうしたルールは Go にありません。`error` はあくまでインターフェース型（`type error interface { Error() string }`）であり、数値的に解釈する仕組みはありません。  
   - C言語などで「0=成功、1=失敗」と返す慣習と混同している選択肢です。

3. **(3) カンマ区切りの戻り値は引数として渡される**  
   - Go では実行時に「戻り値を別関数に渡す」場合、明示的に呼び出しを組み合わせなければ自動的には行われません。たとえば `f(g())` のように書けば `(x, y)` が `g()` の戻り値として渡されるが、それはあくまで呼び出し側の書き方次第です。  
   - カンマ区切りで書かれた戻り値は**「複数の値として同時に返す」**という仕組みであり、本問の核心的な回答になりません。

4. **(4) 「エラーを返す場合でも `panic` が実行される」**  
   - Go では通常「エラー時は `panic` する」のではなく、「エラー値(`error`)を返す」手法が推奨されます。  
   - もちろん致命的な状況で `panic` を使うこともありますが、**すべてのエラーが `panic` になるわけではなく**、大半は `(T, error)` の戻り値でハンドリングします。

**Go のエラー処理における `(result, error)`**
- **スローとキャッチ(Exception) ではなく**、関数の戻り値としてエラーを返すのが Go の基本設計。  
- 呼び出し側は `x, err := doSomething(a, b)` と受け取り、`if err != nil { ... }` で分岐処理を行う。  
- これにより、**エラー確認を強制**しやすくなり、ソースコード上も「いつエラーが発生しうるか」が明示的です。

---

### Q16 (穴埋め: sumSlice)
**問題**:  
以下の関数 `sumPositive` は、渡された `nums` スライスの要素のうち、**正の数**だけを合計して返したいという要求があります。空欄( A ) を埋めるとしたら、どの書き方が最も正しいでしょうか？

```go
func sumPositive(nums []int) int {
    total := 0
    for (A) {
        if val > 0 {
            total += val
        }
    }
    return total
}
```

1. `for val in nums:`  
2. `for _, val := range nums`  
3. `for i, val in range nums`  
4. `for i := 0; i < len(nums); i++`

**解答**: **(2)**

**解説**:  
Go でスライスをループする際は `for _, val := range nums` が代表的な構文です。インデックスを使わないなら `_` で捨て変数にし、`val` を要素として扱えます。ここでは「正の数のみ加算」という要件に合わせて `if val > 0 { total += val }` と書くと目的を果たせます。

**他の選択肢**:  
- (1) `for val in nums:` は Python 風であり、Go の文法ではありません。  
- (3) `for i, val in range nums` も Python / JavaScript の混同で、Go には存在しません。  
- (4) `for i := 0; i < len(nums); i++` は構文上正しいが、問題文の空欄 `(A)` と合わせて「val を range で取得する」には当てはまりません（かつ `i` でアクセスするなら `val` は別途 `nums[i]` が必要）。

---

### Q17 (穴埋め: 複数戻り値のシンタックス)
**問題**: Go で**複数の戻り値**を返す関数を書くとき、どのようなシンタックスを使うか。

**回答**: `func sample(x int) (int, bool) { ... }`

**解説**:- `(type1, type2, ...)` の形で複数の戻り値を並べられるのが Go の大きな特徴。 

---

### Q18 (選択: Go のテストファイル)
**問題**: Go のテスト (`go test`) でテスト関数を書く際の命名規則は何か。

1. テストファイル名を `test_???_go` とし、関数名は何でもよい  
2. `main.go` の中に `func testMain()` を書けば自動的にテストされる  
3. テストファイル名を `_test.go` とし、関数名を `TestXxx(t *testing.T)` の形にしなければならない  
4. Go では標準テスト機能が無い

**解答**: **(3)**

**解説**
**Go の標準テストフレームワーク**
Go には、標準パッケージとして **`testing`** が用意されており、`go test` コマンドを使って自動的にテストを実行できます。追加の外部ライブラリを必要とせず、**標準でユニットテストや簡易ベンチマーク、例示的テスト**などが可能です。

**テストファイルの命名規則**
- **「ファイル名を `_test.go` で終わらせる」**  
  - たとえば `calc_test.go`, `stringutil_test.go` のように書きます。  
  - これにより、`go test` がテストファイルとして自動認識し、コンパイル＆実行に組み込みます。

**テスト関数の命名規則**
- **「関数名を `TestXxx(t *testing.T)` の形にする」**  
  - `Xxx` には任意の識別子を付け、例えば `TestAdd`, `TestSomething` のように書くと、`go test` が「この関数はテスト関数だ」と認識。  
  - 関数のシグネチャは必ず引数に `*testing.T` を取り、戻り値なし (`func TestXxx(t *testing.T)`) とする必要があります。

**他の選択肢が誤り・不十分な理由**
1. **(1) 「ファイル名を `test_???_go` とし、関数名は何でもよい」**  
   - 実際には `test_???_go` ではテストファイルとして認識されません。正式には `_test.go` のサフィックスが必要ですし、関数名も `TestXxx` としなければ `go test` はテストとして扱いません。

2. **(2) 「`main.go` の中に `func testMain()` を書けば自動テストされる」**  
   - こうした仕組みはありません。`main.go` そのものは通常アプリのエントリーポイントであり、`testMain()` という特別な関数は存在しません。

3. **(4) 「Go では標準テスト機能が無い」**  
   - 誤り。Go には標準のテスト機能 (`testing` パッケージ、`go test`) があり、追加のライブラリなしでユニットテストを実行できます。

---

### Q19 (選択: スライスの部分範囲)
**問題**:`s := []int{10, 20, 30, 40, 50}` とし、`sub := s[1:4]` とした場合、`sub` は何を指すか。

1. `[10,20,30]`  
2. `[20,30,40]`  
3. `[30,40,50]`  
4. `[10,20,30,40]`

**解答**: **(2)**

- **解説**:
**スライスの部分範囲**
- `s[1:4]` は「`s` のインデックス 1 から 4 未満まで」を指す。つまり `s[1], s[2], s[3]` が含まれる。したがって `sub` は `[20,30,40]` となります。

---

### Q20 (判断: マップ追加・更新)
**問題**: Go のマップにおいて、キーを追加・更新する操作 `m[key] = value` は同じ書き方で行える。

- (A) Yes  
- (B) No  

**解答**: **(A)**

**解説**:- もし `key` が存在しなければ**追加**、存在すれば**上書き**。同じ構文で両方できる点は Go のマップの特徴です。

---

## Level 3（中級～やや上級入り口）

### Q21 (選択: 構造体とは)
**問題**: Go の構造体 (struct) について、正しい説明はどれか。

1. `type Person struct { Name string; Age int }` のように、複数のフィールドをひとまとめにできる  
2. Go の構造体はコンパイル時にクラスへ変換され、すべてのフィールドにコンストラクタが自動生成される  
3. フィールド名をすべて大文字にしないと、同じパッケージ内でも構造体のメモリ領域にアクセスできない  
4. 構造体のフィールドにスライスを入れるときは別途 `makeStructSlice(...)` を呼び出すため、標準型を直接使えない  

**解答**: **(1)**

**解説**
1. **(1) が正解**  
   - Go の構造体は、関連する複数のフィールドをまとめるためのカスタム型。  
   - 例えば `type Person struct { Name string; Age int }` のように書けば、`Person` という新しい型ができ、`Name` と `Age` の2つのフィールドをまとめて扱えます。  
   - 構造体そのものに“クラス”のような継承機能はありませんが、メソッドを定義して使うことは可能です（`func (p Person) SomeMethod() { ... }` 等）。

2. **(2) 「コンパイル時にクラスへ変換+自動コンストラクタ」**  
   - Go に“クラス”という概念はありません。構造体はそのまま低レベルにメモリレイアウト(データがメモリの中でどの順番・位置に並ぶかを決める)され、コンストラクタは自動生成されません（必要なら手動で初期化関数を書く）。

3. **(3) 「すべて大文字にしないと同パッケージ内でアクセスできない」**  
   - Go では大文字/小文字が**エクスポート（パッケージ外公開）**を決定します。同じパッケージ内であれば、小文字フィールドでも自由にアクセス可能。  
   - 大文字にしなければ外部からは見えませんが、同パッケージ内では問題ありません。

4. **(4) 「フィールドにスライスを入れるときは `makeStructSlice(...)` が必要」**  
   - Go で構造体のフィールドにスライスを持たせる場合は、単に `[]T` フィールドを宣言し、必要に応じて `make` やスライスリテラルで初期化すればOK。`makeStructSlice(...)` という特別な関数は存在しません。  
   - 例えば:
     ```go
     type Person struct {
         Friends []string
     }
     p := Person{ Friends: []string{"Bob","Carol"} }
     ```
     などとすれば問題なく使えます。

---

### Q22 (選択: 値レシーバとポインタレシーバ)
**問題**: 以下のメソッド宣言で `(p Person)` と `(p *Person)` が異なる理由は何か。

```go
func (p Person) ChangeName(newName string) {
    p.Name = newName
}
func (p *Person) UpdateAge(newAge int) {
    p.Age = newAge
}
```

1. 値レシーバでは構造体のコピーを操作し、ポインタレシーバならオリジナルを更新できる  
2. ポインタレシーバは内部的にメモリマップを直接いじるため、一度でも `nil` が入ると二度と再利用できなくなる  
3. 値レシーバでメソッドを書くと、メソッド呼び出し中にガーベッジコレクタが動いても安全だが、ポインタだと危険  
4. 動作結果は同じだがコンパイラが選択する命令セットが異なり、最適化の都合でポインタレシーバの方が数倍遅い  

**解答**: **(1)**

**解説**
**レシーバの値・ポインタ**
Go では、構造体メソッドのレシーバを「値」か「ポインタ」で受け取るかを選べます。
- **値レシーバ `(p Person)`**  
  - メソッド内で `p` は**構造体のコピー**。  
  - `p.Name = newName` のように書いても、呼び出し元の変数には反映されません（コピーを操作しているだけ）。
- **ポインタレシーバ `(p *Person)`**  
  - メソッド内で `p` は構造体へのポインタ（実体を指すアドレス）  
  - `p.Name = newName` のように書くと、呼び出し元の実体を**直接変更**できる。

**なぜ (1) が正解か**
> **「値レシーバでは構造体のコピーを操作し、ポインタレシーバならオリジナルを更新できる」**
- **値レシーバ**は**コピー**を操作するため、元の構造体には影響を与えません。
- **ポインタレシーバ**は**元の構造体**を直接操作するため、呼び出し元の変数にも反映されます。
- このため、値レシーバ`(p Person)`は「コピーを操作する」、ポインタレシーバ`(p *Person)`は「元の構造体を直接操作する」という違いがあります。

**他の選択肢**
1. **(2)「ポインタレシーバは内部的にメモリマップを直接いじるため…」**  
   - 確かにポインタはアドレスを持ちますが、「一度 nil が入ると二度と再利用できない」などは誤解。`nil` ポインタなら `p == nil` 判定など行えますし、別の実体を再度代入すれば使えます。
2. **(3)「値レシーバなら GC が動いても安全、ポインタなら危険」**  
   - Go のガーベッジコレクタはポインタを追跡できますし、通常は危険ではありません。ポインタレシーバだから GC が絡んで危険になるわけではありません。
3. **(4)「動作結果は同じで、コンパイラの命令セットが違う」**  
   - 動作結果は明確に異なります。値レシーバはコピーを変更、ポインタレシーバは元のインスタンスを変更します。コンパイラの最適化による速度差も一概には言えません。
---

### Q23
**問題**:  
以下の `Rect` 構造体には `Width` / `Height` があり、メソッド `Area()` は定義済みです。新たに「特定の幅・高さに更新する」処理をしたいが、呼び出し元にも反映されるようにしたい。どうメソッドを定義すればよいでしょうか？

```go
type Rect struct {
    Width  int
    Height int
}

func (r Rect) Area() int {
    return r.Width * r.Height
}
```

1. 
  ```go
  func (r Rect) SetSize(w, h int) {
    r.Width = w
    r.Height = h
  }
  ```

2. 
```go
func (r *Rect) SetSize(w, h int) {
    r.Width = w
    r.Height = h
}
```

3. 
```go
func (r Rect) SetSize(w, h int) Rect {
    r.Width = w
    r.Height = h
    return r
}
```

4. 
```go
func (r *Rect) SetSize(w, h float64) {
    r.Width = int(w)
    r.Height = int(h)
}
```

**解答**: **(2)**

**解説**:  
値レシーバ (r Rect) だと `r.Width = ...` はコピー上の操作になるため、呼び出し元の `Rect` に影響しません。**ポインタレシーバ (r *Rect)** なら元の実体を変更できるので、(2) が適切。なお、(4) は引数型が float64 で別意図。（もし本当に浮動小数からキャストしたいならありえますが、本問は「幅・高さが int で変更したい」だけが要旨です）。

**他の選択肢**:  
- (1) 値レシーバだと呼び出し元に反映されない  
- (3) 値レシーバ+戻り値で更新結果を返す手段もあるが、呼び出し側の書き方次第で混乱しがち  
- (4) 浮動小数から int へキャストするパターンは意図が異なる
---

### Q24 (選択: ゴルーチン起動)
**問題**:  
Go でゴルーチンを起動するキーワードとして正しいのはどれですか？

1. `defer`  
2. `go`  
3. `switch`  
4. `run`

**解答**: **(2)**

**解説**:  
Go では、並行に関数を動かすため `go someFunction()` と書きます。これだけで新たなゴルーチンが生成され、呼び出し元とは別に処理が進行します。

**他の選択肢**:  
- (1) `defer` は関数終了時に遅延実行する仕組み。並行起動ではありません。  
- (3) `switch` は条件分岐。  
- (4) `run` はGo 文法に存在しないキーワードです。

---

### Q25 (選択: インターフェースの実装)
**問題**: Go のインターフェースはどのように実装が判断されるか。

1. 明示的に `implements InterfaceName` と書く  
2. 構造体が「インターフェースが要求するメソッドを全て持っていれば」暗黙的に実装とみなされる  
3. `interface{}` は何でも受け取れるが実装判定はできない  
4. インターフェースはJavaやC#だけにある概念で、Goには存在しない  

**解答**: **(2)**

**解説**
1. **Go の「暗黙の実装方式」**
   - Go のインターフェースは、**“インターフェースが要求するメソッドを型が全部持っていれば、その型はそのインターフェースを実装している”** とみなされます。  
   - たとえば `io.Writer` インターフェースは `Write(p []byte) (n int, err error)` メソッドを要求しますが、型がこのメソッドを持っているなら、特に宣言しなくても自動的に「`io.Writer` を実装している」と認識されます。
   - これを **「暗黙の実装（implicit implementation）」** あるいは **「structural typing」** と呼び、Java や C# のような「implements」キーワードを用いる“明示的実装”とは対照的です。
2. **(2) が正解**
   - **(2)** は **「構造体がインターフェースが要求するメソッドをすべて持っていれば暗黙的に実装とみなされる」** という、Go のインターフェース実装法を正しく表しています。
3. 他の選択肢
   - **(1)「明示的に `implements InterfaceName` と書く」**  
     - 他言語(Java/C#)では見られる構文ですが、**Go には存在しません**。  
   - **(3)「`interface{}` は何でも受け取れるが実装判定はできない」**  
     - `interface{}` (空インターフェース) は「任意の型を代入可能」という特徴がありますが、実際には“すべての型が自動的に実装している”とも言えます。とはいえ「実装判定できない」という表現は誤解を招きます。むしろ “メソッド要件がない” ため、あらゆる型を受け入れるのが空インターフェースです。
   - **(4)「インターフェースはJavaやC#だけにある概念で、Goには存在しない」**  
     - Go には**独自のインターフェース**が存在し、本問の核心である「暗黙の実装」という大きな特徴があります。よって明らかに誤りです。

---

### Q26 (単純回答: `error`型)
**問題**:  
Go における `error` は「(T, error)」で返す慣習がありますが、以下のように**いくつかの段階**（ファイルを開く → JSON デコード → さらに構造体を検証）で失敗するかもしれないコードがあるとします。どの方法が最も一般的でしょうか？

1. すべてのエラーを `panic` にし、recover でまとめてハンドリング  
2. 各段階で `(T, error)` を返し、呼び出し元が `if err != nil { return ... }` する  
3. Go はエラー概念を持たないため、C言語的に 0/1 を戻す  
4. デバッグ時のみ fmt.Println(...) でエラーを表示し、本番は何もチェックしない

**解答**: **(2)**

**解説**:  
Go の代表的エラー処理は**段階ごとにエラーを返し、失敗なら早期リターン**する方針。`panic/recover` は致命的エラー用や本当に例外的な場面だけに使います。  

**他の選択肢**:  
- (1) すべて panic は通常の業務エラー処理としては過剰。  
- (3) `error` インターフェースがあるのにC的数値戻りは非推奨。  
- (4) デバッグのみエラー出力→本番で捨てる、は危険。
---

### Q27 (選択: チャネル受信)
**問題**: 以下の並行処理コードで、チャネル `results` が `make(chan string)` として作られている。正しい説明はどれか。

```go
msg := <- results
```

1. **これは受信ブロックを表し、`results` から文字列が送られてくるまで待つ**  
2. これは送信ブロックを表し、msg が入るまで待つ  
3. Go では `<-` 演算子は存在しない  
4. これはデッドロックを必ず起こす  

**解答**: **(1)**

**解説**
1. **Go のチャネルと `<-` 演算子**
   - Go では、チャネルを使ってゴルーチン間でデータを送受信します。書き方は以下の通りです:  
     - **送信**: `results <- "some string"`  
     - **受信**: `value := <-results`
   - 受信側のコード `value := <-ch` は、**チャネル `ch` から値が届くまで待機**する（ブロックする）仕組みです。
2. **(1) が正解**  
   - `msg := <- results` は**受信操作**です。`results` に誰かが `results <- "someData"` と送信するまで待ち、その送られた文字列を `msg` に格納します。
3. 他の選択肢
   - **(2)「これは送信ブロック」**  
     - 送信ブロックは `results <- something` の形。`<- results` は受信。
   - **(3)「Go では `<-` 演算子は存在しない」**  
     - Go の並行処理では `<-` は必須。実際に存在します。
   - **(4)「これはデッドロックを必ず起こす」**  
     - 必ずではありません。送信するゴルーチンがいれば正常に動作します。デッドロックになるかどうかは送信側の実装やチャンネルバッファ状況次第です。

---

### Q28 (穴埋め: ゴルーチンで sayHello)
**問題**:  
以下の `worker` 関数を**並行**に3つ起動し、それぞれが特定の仕事をする。一方、メイン関数が先に終わってしまうとプログラム全体が終了してしまう。Go で待ち合わせるにはどうすべきでしょうか？

```go
func main() {
    for i := 0; i < 3; i++ {
        go worker(i)
    }
    // ここでどうやって「3つのworkerすべて終了」を待てるか？
    fmt.Println("all done")
}
```

1. time.Sleep(5 * time.Second) で大体待つ  
2. sync.WaitGroup を使って Add(3), Done(), Wait() を組み合わせる  
3. 3つの global bool 変数を worker で true にして main でfor{}でチェック  
4. net.Conn を使って Socket通信し、closeを検知する

**解答**: **(2)**

**解説**:  
「**sync.WaitGroup** を使う」ことが Go で並行ゴルーチンの終了待ちを行う**代表的かつ実務的**な方法です。Add(n) → 各ゴルーチン Done() → mainで Wait() という流れ。  
この問題を解くと**「Go の並行処理でどう待機するか」**を習得でき、time.Sleep やグローバル変数監視などより正攻法だと分かります。

**他の選択肢**:  
- (1) Sleep は不確実。  
- (3) グローバル変数を3個持ち回りチェックは可読性が低く悪手。  
- (4) net.Conn で無理やり終わりを通信するのは用途違い。

---

### Q29 (判断: メソッドのレシーバは任意の型)
**問題**: Go のメソッドは、構造体だけでなく任意の型（例えば `type MyInt int`）に対しても定義できる。

**解答**: **(A)**

**解説**
Go では、**自分で定義した型**（たとえば `type MyInt int`）に対してもメソッドを定義できます。構造体だけが対象ではありません。以下のように書けます:

```go
type MyInt int

func (m MyInt) Double() MyInt {
    return m * 2
}
```

これにより、`MyInt(5).Double()` のように呼び出すと、`10` が返ります。ただし、**組み込み型 (int, string など) を直接拡張する**わけではなく、**自分で定義した型の別名**として宣言したもの（`type MyInt int` など）であればメソッドを持たせられる、という仕組みです。

---

### Q30 (短答: 複数戻り値 `(result, error)` の設計意図)
**問題**:  
Go で「複数の戻り値 `(result, error)`」を返す設計の背景として、「例外をスローせず明示的に扱う」方針があります。では、エラーをどうやって呼び出し側に伝え、処理するのが一般的でしょうか？

1. 例外発生時はコンパイラがエラーコードを埋め込み、実行停止する  
2. `(result, err)` を返し、呼び出し側が `if err != nil { ... }` で対処する  
3. `panic` を起こし、recover しなければ即プロセス終了  
4. Go にはエラーと例外の概念が存在しない

**解答**: **(2)**

**解説**:  
Go は `(normalValue, error)` を返す作法を推奨。呼び出し元で `err != nil` を明示的にチェックするのが基本です。`panic/recover` もあるが、通常の失敗処理には使わず、致命的エラーでのみ利用します。

**他の選択肢**:  
- (1) 例外機構をコンパイラが挿入する仕組みはありません。  
- (3) `panic` は使えるが一般的エラー処理には向きません。  
- (4) Go に `error` インターフェースはちゃんと存在します。

---

## **Level 4 (Q31～Q40)**

### Q31 (選択: `select` で複数チャネル待ち)
以下のコードは複数のチャネルを同時に待つために書かれています。どの構文が正しいか？

```go
select {
( A )
    fmt.Println("got from dataCh:", v)
( B )
    fmt.Println("timeout!")
}
```

1. (A) `case v := <-dataCh:` 、 (B) `case <-time.After(5 * time.Second):`  
2. (A) `v := <-dataCh:` 、 (B) `<-time.After(5 * time.Second):`  
3. (A) `case dataCh-> v:` 、 (B) `case timeout:`  
4. (A) `if dataCh != nil` 、 (B) `default:`  

**解答**: **(1)**

**解説**
1. **正しい `select` 文の基本**
- Go で複数チャネルを同時に待つ典型的パターンは、以下のように**各行に `case` キーワード**と**送受信演算子**を明示します。
    ```go
    select {
    case v := <-dataCh:
        // dataCh から受信
        fmt.Println("got from dataCh:", v)
    case <-time.After(5 * time.Second):
        // 5秒経過でタイムアウト
        fmt.Println("timeout!")
    }
    ```
- **`case v := <-dataCh:`** → `dataCh` から受信。変数 `v` に格納。  
- **`case <-time.After(5 * time.Second):`** → 5秒後にシグナルが届くチャネルを待ち受ける（タイムアウト処理）。
2. **(1) が正解**
  - (A) `case v := <-dataCh:` は**典型的な受信パターン**に合致。(B) も `case <- time.After(5 * time.Second):` は**典型的なタイムアウト処理**の書き方です。

**他の選択肢**
**(2)**
- **問題点**:  
  - ここでは (A) `v := <-dataCh:` に **`case` キーワードが無い**。`select` 文の中では `case ...:` が必須なので文法的に成立しません。  
  - (B) も同様に `<-time.After(5 * time.Second):` だけで `case` がないので正しい受信表現にもなっていません。

**(3)**
- **問題点**:  
  - `dataCh-> v` は Go には存在しない文法（C++ や他言語とも違う誤記）。Go での受信は `v := <-dataCh` か `<-dataCh`。  
  - `case timeout:` もタイムアウトの仕組みが具体的に書かれていないし、`timeout` がどんなチャネルか不明。  
  - これも Go の文法として誤りが多い。

**(4)**
- **問題点**:  
  - `select` 文の中に `if dataCh != nil` という条件を直接書くことはできず、**`case` 節でのチャネル操作**が目的なのに逸脱している。  
  - `default:` はフォールバック節として使える場合があるが、この問題で「複数チャネルを同時に待つ」実装として正しくない。

**ワンポイント: `<-time.After(...)` の意義**
- **`time.After(d)`** は「`d` 時間後にシグナルを送るチャネル」を返します。  
- **`case <-time.After(d):`** と書くことで「指定時間後に実行される」タイムアウト処理を追加するのが典型的です。

---

### Q32 (選択: WaitGroup)
**問題**: Go の並行処理で「WaitGroup」を使う目的は何か？

1. すべてのゴルーチンが終了するまでメイン関数が終わらないようにするため  
2. ゴルーチンを終了強制するため  
3. “シングルトン”パターンを実装するため  
4. `select` 構文で使わないとコンパイルエラーになる  

**解答**: **(1)**
**解説**
**(1) が正解**  
   - **WaitGroup** は、起動したゴルーチンの数をカウントし、それらが全部終了するのを待ってからプログラムを先に進めるための仕組みです。  
   - 典型的には以下のように使います：
     ```go
     var wg sync.WaitGroup
     
     wg.Add(1)
     go func() {
         defer wg.Done()
         // 何らかの処理
     }()
     
     wg.Wait() // ここでゴルーチンが終了するのを待つ
     ```
   - メイン関数で `wg.Wait()` を呼べば、**すべてのゴルーチンが終わるまでメイン関数が終了しない**よう制御できます。
**(2)「ゴルーチンを終了強制するため」**  
   - WaitGroup は終了を**強制する**仕組みではありません。ゴルーチン内で `Done()` を呼んでもらうのを待つだけなので、「強制終了」はできません。
**(3)「“シングルトン”パターンを実装するため」**  
   - WaitGroup は並行処理の“待ち合わせ”に使う機能であり、デザインパターンとしてのシングルトンを実装するための機構ではありません。
**(4)「`select` 構文で使わないとコンパイルエラーになる」**  
   - WaitGroup は `select` とはまったく無関係で、**単独**で使用できます。`select` を用いなくても WaitGroup は問題なく動作します。

---

### Q33 (記述: デッドロック修正)

**問題 (再掲)**: コード補足付きの「URLの数だけ送信するのに1回しか受信していない」バグ。  
**解答例**:

- **回答**: 「`len(urls)` 回だけ `res := <- results` を行う（ループで3回受信）すればOK」  
  - 例:  
    ```go
    for i := 0; i < len(urls); i++ {
        res := <-results
        fmt.Println(res)
    }
    ```  
  - または `WaitGroup` を使ってゴルーチンが終わるのを待つ方法なども考えられるが、単純には「送信分だけ受信する」ロジックが大切。

**解説**:  
- ゴルーチンが3回 `results <- ...` を行うなら、メイン側も3回 `<-results` しなければチャネルが詰まり、デッドロックになる。

---

### Q34 (穴埋め: context)

**問題 (再掲)**:
```go
func work(ctx context.Context) {
    for {
        select {
        case <- (A):
            return
        default:
            // 作業を続行
        }
    }
}
```

**解答**: **(A) `ctx.Done()`**

**解説**:  
- `ctx.Done()` は「キャンセルやタイムアウトが通知されるチャネル」。`case <-ctx.Done(): return` としておけば、キャンセル時にループを抜けられる。

---

### Q35 (選択: ジェネリクス基礎)
**問題**: 以下のジェネリック関数がコンパイルエラーになる理由は？

```go
func max[T any](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

1. `any` はあらゆる型を受け取れるが、`>` 演算子が使える型とは限らないためコンパイルエラー  
2. Go のジェネリクスはすべて数値比較が可能な仕様なので、本来 `a > b` は許されるが `return b` が未定義になる  
3. `T` がインターフェースの場合は比較できず、具体型の場合のみ比較できるがコンパイラは型を判定しない  
4. ジェネリクスを使うときは `map[T]T` のような構文を必ず書く必要があるので、この例は誤用  

**解答**: **(1)**

**解説**
**(1) が正解**
   - **`any`** は「どんな型でも受け付ける」制約ですが、Go のコンパイラは「`any` と書かれた型 `T` が `>` 演算子をサポートするとは限らない」と判断し、**このコードをコンパイルエラーにします**。  
   - もし実際に数値や文字列など “比較可能” な型だけを想定するなら、`constraints.Ordered` や独自の型制約を使う必要があります。  
   - たとえば以下のようにすればコンパイルが通る（`constraints.Ordered` は数値や文字列など `>` が使える型を意味する）:
     ```go
     import "golang.org/x/exp/constraints"

     func maxVal[T constraints.Ordered](x, y T) T {
         if x > y {
             return x
         }
         return y
     }
     ```
**(2) 「Go のジェネリクスはすべて数値比較が可能」**
   - 誤りです。Go 1.18 以降のジェネリクスでも、特定の型制約なしに `>` を使えない。`any` は “あらゆる型” なので演算子を保証しません。
**(3) 「`T` がインターフェースの場合は比較不可…コンパイラは型を判定しない」**
   - 型推論を行うが、`any`(=`interface{}`) は演算子をサポートせず、単に「コンパイラが型を判断しない」わけではありません。誤解が混ざっています。
**(4) 「ジェネリクスで `map[T]T` のような構文が必須」**
   - Go ジェネリクスに `map[T]T` のような記述を必ず書く必要はありません。何らかの型パラメータを受ける関数や構造体を定義するときに、この形が必須というわけではない。

---

### Q36 (穴埋め: constraints.Ordered)

**問題 (再掲)**:
```go
func maxVal[T (B)](x, y T) T {
    if x > y {
        return x
    }
    return y
}
```
**解答**: **(B) → `constraints.Ordered`**

**解説**:
- `constraints.Ordered` は「大小比較が可能な型」を表す制約。`T` が `constraints.Ordered` なら `x > y` がコンパイル通る。
- Goでは型パラメータ `T` に制約を課すことができ、`[T 任意の型]` と書くことで `T` に対して任意の型を受け入れるという制約を設けることができます。
**例:**
```go
func maxVal[T constraints.Ordered](x, y T) T {
    if x > y {
        return x
    }
    return y
}
```
- このように `constraints.Ordered` を使うことで、`T` が大小比較可能な型であることを保証できます。

---

### Q37 (選択: カスタム制約)
**問題**: Go で自作の制約 (constraint) を定義する場合の書き方は？

1. `type MyConstraint interface { ~int|~float64 }` のようにインターフェースで定義  
2. constraints は標準ライブラリのみでカスタム不可  
3. constraintを作るには `constraint MyConstraint = "T"` と書く  
4. ジェネリクスで制約は使わない  

**解答**: **(1)**

**解説**
**(1) が正解**  
   - Go 1.18 以降、ジェネリクスを使うときに「型パラメータがどんな型を受け入れられるか」を制約 (constraint) として宣言可能です。  
   - 例えば、以下のように書くと「`~int` や `~float64` の底型を持つ型」をまとめて受け入れるコンストレイント (カスタム制約) を定義できます:
     ```go
     type MyConstraint interface {
         ~int | ~float64
     }
     ```
   - こうした“型セット”表記 (`~int|~float64`) は「この制約を満たす型パラメータ T は、底型が int か float64 に“近い”型（例: `type MyInt int` など）を受け入れる」という意味になります。  
**(2) 「constraints は標準ライブラリのみでカスタム不可」**  
   - 誤りです。Go は自前のインターフェースで独自制約 (`type MyConstraint interface {...}`) を書くことができます。  
   - ただし標準ライブラリにも `constraints.Ordered` などが用意されており、よく使われます。
**(3) 「constraintを作るには `constraint MyConstraint = "T"` と書く」**  
   - こういった書式は Go にはありません。Go では通常、`type MyConstraint interface { ... }` の形で制約を宣言します。
**(4) 「ジェネリクスで制約は使わない」**  
   - 実際には、ジェネリクスで演算子やメソッドを使いたい場合に**制約が重要**です。まったく制約を使わないと、`any` のように汎用型になりますが、`>` 演算子などは使えません。  
   - 演算子や特定メソッドを利用する場合は「どんな型がその演算やメソッドをサポートするか」明示するために制約が不可欠となります。

---

### Q38 (記述: ラップエラー `%w`)

**問題**: `fmt.Errorf("wrap: %w", err)` で元のエラーを包む利点を1行で述べる。

**解答例**:  
- 「上位レイヤーで `errors.Is` / `errors.As` を使って、包まれた元エラーを判定できるようになる。」

**解説**:  
- `%w` でラップする → `errors.Is` / `errors.As` により原因となるエラーを遡って調べられる。
- 例えば `fmt.Errorf("wrap: %w", err)` でエラーをラップすると、`errors.Is(err, targetErr)` で `targetErr` が包まれているか調べられる。

---

### Q39 (穴埋め: sync.Mutex)

```go
var mu sync.Mutex
var count int

func increment() {
    mu.(C)()
    count++
    mu.(D)()
}
```

**解答**:  
- (C) → `Lock`  
- (D) → `Unlock`

```go
mu.Lock()
count++
mu.Unlock()
```

---

### Q40 (選択: `select` + `default:`)
**問題**: 並行処理で `select` 文に `default:` 節を入れるとどうなるか？
1. `default:` がある場合、チャネルが準備されていなくても即座に抜けられるためブロックを回避できる  
2. `default:` を書くとすべてのチャネル受信が無効化され、次のコード行に強制ジャンプが行われる  
3. `select` が並行に複数の受信を待てなくなるので、必ずひとつのチャネルしか扱えない構造になる  
4. `default` はswitch文専用のキーワードなので、`select` で使うとコンパイルエラーになる

**解答**: **(1)**

**解説**
**(1) が正解**  
   - Go の `select` 文で `default:` 節を設けると、ほかの `case` がどれも「準備できていない」場合でも**すぐに `default:` 節が実行**され、ブロックを回避できます。  
   - 例えば以下の例:
     ```go
     select {
     case msg := <-ch:
         fmt.Println("received:", msg)
     default:
         fmt.Println("no message ready, continue immediately")
     }
     ```
     ここで `ch` に送信されていない・受信の準備ができていないなら、即座に `default:` が実行され、ブロックせず次に進みます。
**(2)「`default:` を書くとすべてのチャネル受信が無効化される」**  
   - 誤り。**もし `case` がすぐに読み取れるデータを持っている**場合、そちらが選ばれます。複数の `case` が準備完了なら擬似ランダムに選ばれる。  
   - すべて準備できていない場合にのみ `default:` が実行される、という仕組みです。
**(3)「`select` が並行に複数の受信を待てなくなる」**  
   - `default:` を設けても、「並行に複数のチャネルを待つ」こと自体は可能です。  
   - ただし、**すべての `case` がブロックする状態**の場合に `default:` がすぐ走り、ブロックせず進むだけです。
**(4)「`default` は switch 文専用なので select で使うとエラー」**  
   - Go では `switch` 文でも `default:` を使いますが、**`select` 文**にも `default:` 節を置けます。コンパイルエラーにはなりません。

---

## **Level 5 (Q41～Q50)**

### Q41 (選択: net/http)
**問題**:  
Go の Gin フレームワークを使って「複数のグループ ( `/api/v1/*` と `/api/v2/*` )」を定義し、それぞれ別のミドルウェアを適用したいとします。以下のコード例ではどう書けば、`/api/v1/users` と `/api/v2/items` それぞれに違うミドルウェアを適用できるでしょうか？

(1)
```go
r := gin.Default()
r.Group("/api")
r.Group("/v1")
r.Group("/v2")

// ... define routes ...
r.Run()
```

(2)
```go
r := gin.Default()
v1 := r.Group("/api/v1", v1Middleware)
{
    v1.GET("/users", usersHandler)
}
v2 := r.Group("/api/v2", v2Middleware)
{
    v2.GET("/items", itemsHandler)
}
r.Run()
```

(3)
```go
r := gin.Default()
r.Use("/api/v1", v1Middleware)
r.Use("/api/v2", v2Middleware)
r.Run()
```

(4)
```go
r := gin.New()
r.Prefix("/api").Prefix("/v1").Use(v1Middleware)
r.Prefix("/api").Prefix("/v2").Use(v2Middleware)
r.Run()
```

**解答**: **(2)**

**解説**:  
Gin で「ルートグループ + ミドルウェア」を適用したい場合、`r.Group("/api/v1", v1Middleware)` のように引数でミドルウェア関数を渡すか、`v1.Use(...)` と書くのが定番パターンです。上記コード例(2)では `v1 := r.Group("/api/v1", v1Middleware)` の中で `/users` エンドポイントを定義しており、(3) や (4) のような書き方はサポートされていません。  
Gin で「複数バージョンの API」を運用する際、「それぞれのルートに異なる認証ミドルウェア/ロギングを掛ける」といった実践的要件が出ます。本問で「`.Group("/path", middleware...)`」のパターンを再確認することで、大規模 API の設計がやりやすくなります。

**他の選択肢**:  
- (1) ただグループを連続で書いても意味がなく、ネストやミドルウェア指定がない。  
- (3) `r.Use("/api/v1", ...)` は文法的に誤り。`Use(...)` はパスを引数にとらず、ミドルウェア関数を渡すもの。  
- (4) `r.Prefix(...)` は存在しない API で、複数回の Prefix 連鎖も非対応です。

---

### Q42 (選択: ハンドラのシグネチャ)
**問題**: `http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {...})` の引数 `w` と `r` は何？

1. `w` と `r` はポインタ同士を相互に参照する循環構造で、実際の読み書きはすべて内部バッファが行う  
2. `r` はサーバー設定の構造体で、`w` はリクエストの中身を読み取るためのストリーム  
3. `w` はレスポンス用の Writer、`r` はクライアントからのリクエスト情報を持つ  
4. `w` はリクエスト用の Writer、`r` はクライアントへのレスポンス情報を持つ  

**解答**: **(3)**

**解説**
**Go のハンドラ関数シグネチャ**
   - `http.HandleFunc(pattern string, handler func(w http.ResponseWriter, r *http.Request))`
   - このシグネチャにある `w` と `r` は、**`w` がレスポンスを書き込むため** (`ResponseWriter` インターフェース)、**`r` がリクエスト情報を表す構造体** (`*http.Request`) という役割です。
**(3) が正解**
   - 「`w` はレスポンス用の Writer（書き込み先）、`r` はクライアントのリクエスト内容を保持する構造体」というのが最も正しい説明です。
   - 実際、`w.Write([]byte("Hello"))` などとすると、サーバがクライアントへレスポンスデータを送信できます。一方 `r.URL` や `r.Method`、`r.Header` などで、リクエストの詳細を取得します。
**他の選択肢**
   - **(1)** 「ポインタ同士が循環構造」：そんな仕組みではありません。`w` と `r` は別々のオブジェクトであり、相互に参照し合う関係ではありません。  
   - **(2)** `r` はサーバー設定ではなく**リクエスト**そのもの。`w` はリクエストの中身を読むのではなく、レスポンスを書き出す側。  
   - **(4)** も真逆。「`w` はリクエスト用 Writer」ではなく、`w` は**レスポンス**側です。

---

### Q43
**問題**:  
モジュール管理で `go.mod` を生成するには `go mod init ...` が定番ですが、**複数のモジュールパス**を同じリポジトリ内で別々に設定したいケースがあります。たとえば subディレクトリごとに異なる `go.mod` を置きたい場合、正しく進めるには？

1. リポジトリ直下で `go mod init rootModule` すればサブディレクトリも自動で別モジュールになる  
2. 各サブディレクトリに cd して `go mod init <modulePath>` を行い、マルチモジュール構成にする  
3. sub1/ sub2/ のフォルダ名を vendor/ に変えればモジュール分割される  
4. Gitのサブモジュールを導入してモジュール管理するとGoが自動推論する

**解答**: **(2)**

**解説**:  
マルチモジュール構成を取りたいなら**各サブディレクトリで `go mod init some/path`** して独立した `go.mod` を生成し、それぞれを別モジュールとして扱うのが正攻法です。

**他の選択肢**:  
- (1) 1つのgo.mod ではサブディレクトリも同一モジュール扱いです。  
- (3) vendor/ は旧依存管理の仕組み、フォルダを vendor にしても別モジュールにはならない。  
- (4) Git サブモジュールは別リポジトリ運用であり、本質的にGo のモジュール機能とは異なる。

---

### Q44 (選択: ディレクトリ構造で `cmd/`)

**問題**:
小規模～中規模の Go プロジェクトで「`cmd/` ディレクトリ」はどのような用途で使われることが多いでしょうか？

1. 依存ライブラリを手動でコピーし、すべてモノリポ化するためのフォルダ  
2. スクリプトや設定ファイル（Dockerfile やCI/CD用YAMLなど）を集約し、`main.go` は `apps/` ディレクトリに置く  
3. 実行可能ファイル（`main` パッケージ）を配置して複数のCLIツールやサブアプリケーションを管理しやすくする  
4. 画像やCSSファイル、ビルド成果物などを バージョン管理下で保管しておくための領域

**解答**: **(3)**

**解説**:
- 小～中規模の Go プロジェクトでは、よく「`cmd/ツール名/main.go`」のようにディレクトリを分けて複数の実行ファイルを管理します。これにより、1つのリポジトリ内でいくつもの CLI ツールやサブアプリをまとめつつ、`internal/` や `pkg/` の共通ロジックを使う形にできるため便利です。
- 例えば、以下のような構成が典型例です:
  ```
  myproject/
  ├── cmd/
  │   ├── toolA/
  │   │   └── main.go
  │   └── toolB/
  │       └── main.go
  ├── internal/
  │   └── ...
  ├── pkg/
  │   └── ...
  ├── go.mod
  └── ...
  ```
- **cmd/**: 実行可能ファイルごとにサブディレクトリを作り、`main.go` を配置  
- **internal/**: 外部からインポートさせたくない内部実装を置く  
- **pkg/**: 公開可能なパッケージや再利用ライブラリ  
  このようにして、プロジェクト単位で整理しやすくなるのが大きなメリットです。
**他の選択肢**:
- (1) 依存ライブラリを手動でコピーする方法は古い `vendor/` モードなどと混同しており、`cmd/` とは無関係です。  
- (2) スクリプトやDockerfileを `cmd/` に置く慣習は一般的ではありません。CI/CD 用ファイルは `build/`、`.github/workflows/`、または `scripts/` などに分けることが多いです。  
- (4) 画像・CSSなどのリソースやビルド成果物は通常、`static/` や `assets/`、`build/` ディレクトリなどに置き、`.gitignore` でバージョン管理外とするのが通例です。

---

### Q45 (選択: Docker マルチステージビルド)
**問題**:  
Go には `init` 関数があり、パッケージ読み込み時に自動実行されます。プロジェクト内に多数のパッケージがあり、それぞれ複数 `init` を書いていたとします。その場合の挙動や注意点として正しいのはどれでしょうか？

1. すべての init 関数はソースファイルの記述順に呼ばれるため、後から書いた順番で優先して実行される  
2. init は main 関数より後に呼ばれるので実行順序を制御できる  
3. Go は `init` 関数が複数ある場合、コンパイルエラーになる  
4. パッケージ間の依存関係 (import順) が決まった後、各パッケージの init が順に呼ばれるが、多用すると読みづらくなる

**解答**: **(4)**

**解説**:  
init 関数は**パッケージ依存関係**に基づいて順番に呼ばれ、1つのパッケージ内に複数 init があってもエラーにはなりません。ただし**「多用するとどこで何が起きるか把握しにくい」**欠点があります。

**他の選択肢**:  
- (1) ソース記述順に呼ばれるのはパッケージレベルでの話になりがちで、importの順が絡むため複雑。  
- (2) init は main より前に呼ばれる。  
- (3) 複数 init でもコンパイルエラーにはなりません。

---

### Q46 (短答: テストカバレッジ)

**解答例**:  
- 「テストで実際に実行されたコード行の割合（カバレッジ）を確認できる。」

**解説**:  
- `go test -cover` で関数や行がどのくらいテストされているか%表示してくれる。
- カバレッジとは「テストで実行されたコード行の割合」を示し、100%に近いほどテストが網羅的であることを示す。
- テストカバレッジを見ることで、どの部分がテストされていないかを把握し、テストの品質を向上させることができます。
- また、`go test -coverprofile=coverage.out` でカバレッジ情報をファイルに出力し、HTMLレポートを生成することも可能です。

---

### Q47 (選択: context.WithTimeout)
**問題**:
`context.WithTimeout(ctx, duration)` を使って一定時間後にキャンセルされるコンテキストを得た場合、タイムアウト後のゴルーチンはどうなるでしょうか？

1. タイムアウトが来た瞬間に、ランタイムがゴルーチンを強制終了させる  
2. ゴルーチンが `<-ctx.Done()` をチェックすれば、キャンセルを受け取って自主的に終了できる  
3. `context.WithTimeout` はデバッグ専用のAPIであり、実行時には何の影響もない  
4. Go は timeout/cancel という概念をサポートしていないため、実行結果は不定

**解答**: **(2)**

**解説**:
Go のコンテキスト機能は「強制終了」ではなく「キャンセルシグナルを送る」仕組みです。`WithTimeout` は指定時間後に `ctx.Done()` が close され、ゴルーチンはそれを受信すれば処理を中断するように **自主的** に動きます。以下が代表例です。
```go
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    go worker(ctx)

    // ここで5秒経過すると、自動でcancel()が呼ばれた状態と同様になり、
    // ctx.Done() がcloseされる
    <-ctx.Done() // メインが待ってみるケース
    fmt.Println("main done")
}

func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            // ここでキャンセル通知を受け取ったらゴルーチンを抜ける
            fmt.Println("worker: received ctx cancel signal")
            return
        default:
            // 通常処理
            time.Sleep(500 * time.Millisecond)
            fmt.Println("worker: doing some work")
        }
    }
}
```

**(2) が正解**:
- ゴルーチン内で `<-ctx.Done()` をチェックすることにより、キャンセルを“確認して”自主的に抜ける形をとります。  

**他の選択肢**:
- (1) タイムアウトが来ても「ランタイムがゴルーチンを強制終了する」わけではなく、「`ctx.Done()` が閉じられて呼び出し側が気づける」だけです。  
- (3) `context.WithTimeout` はデバッグ専用ではなく、実際のサーバや CLI プログラムでも一般的に使われるAPIです。  
- (4) Go にはキャンセル/タイムアウトの概念がしっかりあり、`context` パッケージが標準で提供しています。
---

### Q48 (選択: ジェネリクス多型パラメータ)
**問題**:  
Go のジェネリクスで「型パラメータを2つ受け取り、それぞれに異なる制約」を付与したいケースがあります。以下の空欄を埋める正しい構文は何ですか？

```go
import "golang.org/x/exp/constraints"

func combine[???](x T, y U) bool {
    // T は Ordered(比較可能)
    // U は 何でも可
    return x > T(0) // など比較使用
}
```

1. `[T constraints.Ordered | U any]`  
2. `[T constraints.Ordered, U any]`  
3. `[T, U constraints.Ordered]`  
4. `[constraints.Ordered T, any U]`

**解答**: **(2)**

**解説**:  
Go 1.18+ で「`func fn[T constraints.Ordered, U any](x T, y U)`」のように、各パラメータに対して**コンマ区切り**で制約を指定するのが正式。これにより T は数値やstring等比較できる型、U はなんでも受け取れる型に限定できます。

問題を解く利点は、**「複数型パラメータに別々の制約を付けるスキル」**を習得できるところです。

**他の選択肢**:  
- (1) `|` は型セット内などに使うがここでは誤り  
- (3), (4) は書式が間違っている

---

### Q49 (穴埋め: interface + generics)
**問題**:  
以下に `Comparable` インターフェースと `maxOf[T Comparable]` 関数があるが、**複数種類の型**（int版, string版 など）を統合的に扱いたいとします。「どんな実装方法」が望ましいか？

```go
type Comparable interface {
    Compare(other any) int
}

func maxOf[T Comparable](x, y T) T {
    if x.Compare(y) > 0 { return x }
    return y
}
```

1. 演算子オーバーロードを定義し、`x > y` を直接書けるようにする  
2. それぞれの型 (MyInt, MyString etc.) が Compare(o any) メソッド内で自分の型にアサートし、大小比較を実装する  
3. Reflection でおおざっぱに `val := reflect.ValueOf(x)` → compare any し、空文字なら負数等  
4. panic していれば maxOf が呼ばれた時点で強制終了する

**解答**: **(2)**

**解説**:  
Go では**演算子オーバーロードが無いため、x > y はできません**。インターフェース `Compare(any) int` を各型が実装するには、`(o.(MyInt))` などで型アサーションし、大小比較結果を整数で返す方式が定番。本問題は**「暗黙の実装方式」**と**「anyへのキャスト」**が必要となるパターンです。
例:
```go
type MyInt int
func (x MyInt) Compare(y any) int {
    if x2, ok := y.(MyInt); ok {
        if x > x2 { return 1 }
        if x < x2 { return -1 }
        return 0
    }
    return -1
}

// maxOfの定義はそのままのため省略

func main() {
    x, y := MyInt(10), MyInt(20)
    fmt.Println(maxOf(x, y)) // 20
}
```

**他の選択肢**:  
- (1) 演算子オーバーロードはGo非対応  
- (3) Reflectionは遅く複雑  
- (4) panicで比較不能なのは意味がない

---

### Q50 (選択: reflect)
**問題**: Go のリフレクション (`reflect`) を使うと何ができるでしょうか？

1. 実行中にソースコードを再コンパイルして、新たな関数を動的に生成する  
2. Go のバイナリ全体を逆アセンブルして、アセンブリ言語に変換して表示する  
3. ランタイム時に型の情報を取得し、動的にフィールド値やメソッドを読み書きできる  
4. Go の型に対して、例外のスローを自在に挿入して例外ハンドラをカスタマイズできる  

**解答**: **(3)**

**解説**:
Go のリフレクション (`reflect` パッケージ) は「実行時に型情報を取得し、フィールドやメソッドを動的に操作できる」仕組みです。具体的には、以下のような場面で使われます。
```go
import "reflect"

func PrintFields(v interface{}) {
    val := reflect.ValueOf(v)
    typ := val.Type()

    // struct の場合、フィールド数や名前・型を取得
    for i := 0; i < val.NumField(); i++ {
        fieldVal := val.Field(i)
        fieldName := typ.Field(i).Name
        fmt.Printf("Field: %s, Value: %v\n", fieldName, fieldVal)
    }
}
```

- 上記のように、**実行時**に “どんなフィールドを持つか” “値は何か” を調べたり、`fieldVal.Set(...)` のように書き換えたりすることが可能です。

**他の選択肢**:
- (1) 実行中にソースコードを再コンパイル…  
  Go のリフレクションはソースコードの再コンパイルや動的関数生成を行いません。あくまで型情報の取得・値の操作に留まります。
- (2) バイナリ全体を逆アセンブルして表示…  
  これは逆アセンブラの機能に近く、`reflect` には含まれていません。Go のリフレクションはアセンブリレベルではなく、高水準の型・値レベルで動きます。
- (4) 例外のスローを自在に挿入…  
  Go は基本的に `(result, error)` でエラー処理を行う言語で、**リフレクションで例外スローを挿入**する仕組みはありません。例外機構そのものが Java/C# のようには存在しないため、誤りです。
---

### **Q51**: Gin の基本ルート設定

**問題**:  
Go の Gin フレームワークで最もシンプルなWebサーバを起動し、`GET /ping` にアクセスすると `"pong"` を返す例のコードとして正しいものはどれでしょうか？  

1. 
```go
r := gin.Default()
r.GET("/ping", func(c *gin.Context) {
    c.JSON(200, gin.H{"message": "pong"})
})
r.Run()
```

2. 
```go
r := gin.New()
r.HttpGet("/ping", "pong")
r.Listen(":8080")
```

3. 
```go
http.HandleFunc("/ping", func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, "pong")
})
http.ListenAndServe(":8080", nil)
```

4. 
```go
gin.Start("/ping", "pong")
```

**解答**: **(1)**

**解説**:  
Gin フレームワークで最もシンプルにWebサーバを起動し、「`GET /ping`」へのアクセスで `"pong"` を返すには、(1) のように以下の流れを踏みます。
- `gin.Default()` でデフォルトのルーターを作成 (ロギングやリカバリなどのミドルウェアが自動適用)  
- `r.GET("/ping", func(c *gin.Context) { ... })` でハンドラ登録し、`c.JSON(...)` によりレスポンスを返す  
- `r.Run()` によって `:8080` ポートで HTTP サーバを起動  

これが、Gin フレームワークで作る最小・典型的なサーバ実装です。

**他の選択肢**:  
- (2) `r.HttpGet("/ping", ...)` は Gin にはないメソッド名であり、`Listen(":8080")` も標準ではありません。
- (3) は Go 標準ライブラリ `net/http` を使った書き方であり、Gin フレームワークではありません。  
- (4) `gin.Start(...)` のようなAPI は存在しません。よく似た名前のユーザ定義ラッパを想起させるかもしれませんが、Gin の公式には用意されていません。

---

### **Q52**: Ginハンドラの引数
**問題**:  
Gin で「IDを URI パラメータから受け取り、JSON ボディに含まれるデータと合わせてDB更新する」という API を作りたい。以下のような例で、ID は `PATCH /users/:id` で受け取り、JSON ボディの `Name, Email` を構造体にバインドして同時に使うには、どう書くのが最適でしょうか？

```go
r.PATCH("/users/:id", func( ??? ) {
    var body struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    // 1) URIパラメータ :id を取得
    // 2) JSONを body にバインド
    // 3) DB更新（擬似的に）: updateUser(id, body.Name, body.Email)
})
```

(1)
```go
func(c *gin.Context) {
    c.BindUri(&body) // combine with BindJSON
    c.BindJSON(&body)
}
```

(2)
```go
func(c *gin.Context) {
    id := c.Param("id")
    if err := c.ShouldBindJSON(&body); err != nil { 
        c.AbortWithError(400, err); return 
    }
    updateUser(id, body.Name, body.Email)
    c.JSON(200, gin.H{"status": "ok"})
}
```

(3)
```go
func(c *gin.Context) {
    c.FormValue("id") // ignoring JSON
    c.PostForm("Name") // ignoring JSON
    c.XML(200, body)
}
```

(4)
```go
func(c *gin.Context) {
    var id string
    c.BindQuery(&id) // assume it's query param
    c.BindJSON(&body)
}
```

**解答**: **(2)**

**解説**:  
Gin では URI パラメータは `c.Param("id")` で文字列として取り出し、**JSON ボディは `c.ShouldBindJSON(&body)`** が代表的なやり方です。本問は「URI と JSON を同時に扱うAPI」という実践的ケース。「ID は URI、Name/Email は JSON」なので (2) の書き方が最適。

- なぜこの問題を解くと良いか:  
  エンドポイント設計において、**URI パラメータ** と **JSON ボディ** を組み合わせるのは極めて一般的（例: `/users/:id` で PATCH / POST など）。Gin でどう取り出すかを知ることは、API 開発の要点です。

**他の選択肢**:  
- (1) `BindUri(&body)` は struct のタグに `uri:"..."` を付けないと使えないし、同じ `body` struct で Param と JSON を共存するのは複雑  
- (3) `FormValue()` / `PostForm()` は x-www-form-urlencoded などフォームデータの取り方で JSON ではない  
- (4) `BindQuery(&id)` はクエリパラメータで、`:id` URI には合わない

---

### **Q53**: JSONバインド

**問題 (再掲)**  
Gin でクライアントが送ってきた JSON を構造体にバインドする代表的なメソッドはどれか？

1. `c.ShouldBindJSON(&obj)`
2. `c.QueryObject(&obj)`
3. `c.DecodeJSON(obj)`
4. `json.NewDecoder(c).Decode(obj)`

**解答**: **(1)**

**解説**  
- `ShouldBindJSON` (または `BindJSON`) は Gin 特有の関数で、HTTPボディを JSON として解析し、指定した構造体にマッピングしてくれます。エラー時は返り値で確認できます（ `err := c.ShouldBindJSON(&obj)` など）。
- (2) `c.QueryObject` は非実在、(3) `c.DecodeJSON` や (4) `json.NewDecoder(c).Decode(obj)` は標準ライブラリスタイルで書く場合の手法ですが、Gin なら簡単に `ShouldBindJSON` が使える。

**次の学習ステップ**:  
- 実際に `ShouldBindJSON` で受け取る構造体にタグ（ `json:"..."` ）を付けてみたり、バリデーションライブラリを使って必須項目のチェックを加えてみると、API作りが実践的になります。

---

### **Q54**: ステータスコードと JSON

**問題 (再掲)**  
「ステータスコード201 を返しつつ JSON ボディ」を1行で返すには？

**解答例**  
```go
c.JSON(201, gin.H{"id": newID})
```

**詳しい解説**  
- `c.JSON(statusCode, any)` はもっともシンプルな書き方で、任意のオブジェクト(`gin.H` や構造体)をJSON化し、指定したHTTPステータスで送信します。201 はリソース作成時の標準ステータスコード「Created」。
- 同様に `c.String(404, "Not Found")` のように文字列を送る方法などもある。

**次の学習ステップ**:  
- さまざまなステータスコード（200, 400, 401, 404, 500 など）と JSON を組み合わせる事例を試し、APIレスポンスを整えると実務的感覚がつかめます。

---

### **Q55**: URI パラメータ

**問題 (再掲)**  
`GET /users/:id` を定義しているルートから、`:id` を取得するにはどう書く？

1. `id := c.Query(":id")`  
2. `id := c.Param("id")`  
3. `id := c.FormValue("id")`  
4. `id, ok := c.Get("id")`

**解答**  
**(2) `id := c.Param("id")`**

**詳しい解説**  
- Gin の `Param` は「`/:param` と定義したURLパスの変数」を取り出すメソッド。例: `/users/:id` → `c.Param("id")` が文字列として返る。  
- (1) `c.Query("...")` はクエリパラメータ `?key=value` 用、(3) `c.FormValue` は net/http 標準のフォーム取得に近いもの（Ginでは通常 `c.PostForm` ）。(4) は `c.Get` でコンテキスト変数を取得するケース。

**次の学習ステップ**:  
- URIパラメータが整数IDなら文字列を `strconv.Atoi` で変換する必要があります。そこからバリデーションの入れ方などを検討すると、より安全なAPIを構築できます。

---

### **Q56**: ルートグルーピング

**問題 (再掲)**  
```go
r := gin.Default()
api := r.(B)("/api")
{
    api.GET("/ping", pingHandler)
    api.POST("/users", createUserHandler)
}
r.Run(":8080")
```
**(B)** に何を入れる？

**解答**  
`Group`

```go
api := r.Group("/api")
```

**詳しい解説**  
- `r.Group("/something")` で「ルートのプレフィックス + ミドルウェアの一括適用」ができる。`/api/ping`, `/api/users` などが定義しやすくなる。  
- サブグループも作るなど階層化できるため、大規模APIで便利。

**次の学習ステップ**:  
- グループにミドルウェアを付加する例（例: `api.Use(AuthMiddleware)`) を学ぶと、ルーティング設計がさらにわかりやすくなります。

---

### **Q57**: ミドルウェア

**問題 (再掲)**  
Gin でグローバルミドルウェアを有効にするには？

1. `r.Use(myMiddleware)`
2. `gin.SetMiddleware(myMiddleware)`
3. `http.HandleMiddleware(myMiddleware)`
4. `myMiddleware(r)`

**解答**  
**(1) `r.Use(myMiddleware)`**

**詳しい解説**  
- `r.Use(...)` を使うと、ルーター全体に対して前後処理やリカバリなどを挟むことができる。  
- 内部的には `r.engine.Handlers` に追加され、リクエストごとに順番に呼ばれる形。

**次の学習ステップ**:  
- ミドルウェアでロギング、認証チェック、CORS設定などを行う事例を学ぶと、本格的なAPI設計が行いやすくなります。

---

### **Q58**: DB と Gin ハンドラ

**問題 (再掲)**

```go
func getItemsHandler( (C) ) gin.HandlerFunc {
    return func(c *gin.Context) {
        // ...
    }
}
```

**解答**: `(C) => db *sql.DB`

```go
func getItemsHandler(db *sql.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        // db.Query(...) 
    }
}
```

**詳しい解説**  
- Go ではクロージャを使い、DBハンドルを引数で受け、Ginのハンドラ関数を返すやり方がよく用いられます。依存注入(DI)の簡易形とも言え、テストや拡張に有利。  
- Alternative: `c.MustGet("db").(*sql.DB)` でコンテキストに仕込む方法もあるが、関数引数で受けるほうが安全・明瞭。

**次の学習ステップ**:  
- 実際に DB クエリ (`SELECT`, `INSERT`) を書き、JSON で返すAPIを作ると、Go + Gin + DB のフローが体験できます。テストデータを仕込んでみるのも効果的です。

---

### **Q59**: クエリ文字列 vs JSONボディ

**問題 (再掲)**  
`GET /something?name=foo` から `name` パラメータを得るにはどの方法？

1. `c.PostForm("name")`
2. `c.Query("name")`
3. `c.ShouldBindQuery(name)`
4. `c.BindURI(&name)`

**解答**  
**(2) `c.Query("name")`**

**詳しい解説**  
- `c.Query("key")` は `/path?key=xxx` のクエリパラメータ取得用。  
- `c.PostForm("key")` は `POST` フォーム, `c.Param("id")` は `/:id`, `c.BindURI` はさらに構造体でURIパラメータをアンマッシュルするような仕組みに使う。

**次の学習ステップ**:  
- 実際に `GET /search?keyword=abc` のようなAPIを用意し、`c.Query("keyword")` を使って検索する例を作ると、クエリ取得を実践できます。

---

### **Q60**: 400 BadRequest

**問題 (再掲)**  
「400 BadRequest と JSON ボディ `{"error": "Invalid input"}` を返す一行」は？

**解答例**:
```go
c.JSON(400, gin.H{"error": "Invalid input"})
```

**詳しい解説**  
- `400` はクライアントのリクエストが不正という意味のステータスコード。Gin でエラーメッセージを JSON で返すパターンはよくあります。  
- これを細かく整形したい場合、構造体を返してキー名を指定したりも可能。ステータスコードについては[HTTP標準]などを参照しましょう。

**次の学習ステップ**:  
- エラー時に `c.AbortWithStatusJSON(400, ...)` と書き、後続処理を打ち切るフローなどを学ぶと、エラー処理設計がはかどります。  
- 実務ではエラーレスポンスを統一的に定義する（エラーコードや詳細メッセージなど）と大規模APIでも混乱が減ります。

---

# **まとめ**

**Q51〜Q60** では、**Go + Gin** の API 開発で重要な基本要素を一通りカバーしました。

1. **ルーティング**: `r.GET("/ping", ...)`, URIパラメータ (`:id` → `c.Param("id")`), クエリパラメータ (`c.Query("key")`), ルートグループ (`r.Group("/api")`), ミドルウェア (`r.Use`)  
2. **JSON 入出力**: `c.ShouldBindJSON(&obj)` で入力、 `c.JSON(200, gin.H{...})` で出力  
3. **DB 連携**: コンストラクタ的にハンドラへ `db` を渡す。`sql.DB` を使う例。  
4. **HTTP ステータスコード** と**エラーハンドリング**: `c.JSON(400, ...)`, `c.JSON(201, ...)` など  

これらを実際に試し、**小さなAPIサーバ**を作ると実務で使える感覚が得られます。**さらなるステップ**としては:

- **JWT 認証**: ミドルウェアでトークンを検証する  
- **Swagger/OpenAPI**: Gin で API ドキュメントを自動生成する  
- **ORM**: GORM などを使い、モデル定義とマイグレーション  
- **Docker/Kubernetes**: コンテナ上で Gin サーバを運用する  

など、いくつかの発展的トピックを学ぶと、**本格的なバックエンド開発**にスムーズに移行できます。以上の問題や解答を活用して、Go + Gin の基礎を着実に身につけてください。