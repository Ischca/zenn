---
title: "総合ミニテスト：全範囲復習（解答）"
free: true
---

# 総合ミニテスト 解答編（Level 1～3）

## Level 1（基礎確認）

### Q1 (選択)
**問題**: Go 言語で「実行可能プログラム」を書くときに必須なのは？  
**選択肢**

1. **「ファイル名を `main.go` にしておく」**  
   - これは Go で実行ファイルを作るときに慣習的に多い例ですが、「必須」ではありません。  

2. **「`package main` と `func main()` を定義する」**  
   - Go で実行可能なバイナリをビルドするためには、最低限 `main` パッケージと `main()` 関数が必要。  

3. **「メイン関数の中で必ず何らかの処理 (print文など) を含める」**  
   - 実際のプログラムでは通常何かしらの処理を書くでしょうが、**空の `main()`** でもビルド自体は可能なので「必須」ではありません。  

4. **「プロジェクトに `import "fmt"` を含め、実行時に出力を行う」**  
   - 多くのサンプルで `fmt` を用いるものの、出力を行わないプログラムもコンパイル・実行できます。必須ではありません。

**解答**: **(2) 「`package main` と `func main()` を定義する」**  

**解説**:
  - Go では、**実行形式**のプログラム（`go build` や `go run` で起動できるバイナリ）を作る際、\**必ず** `package main` と `func main()`** のセットが必要となります。  
  - (1), (3), (4) はいずれも「一般的にそう書くことが多い」「便利な書き方」といったレベルの話であり、**“必須条件”**ではありません。たとえばファイル名が `main.go` でなくても、空の `main()` でも、`fmt` を使わずともバイナリは生成できます。

---

### Q2 (選択)
**問題**: 次のコードについて正しい説明は？
```go
var name string
name = 123
fmt.Println(name)
```

1. **Go では、変数をいったん宣言すれば、同じスコープ内で何度でも再代入が可能**  
2. **このコードはコンパイルエラーになる。`name` が `string` なのに `123` (整数) を代入しており、型が不一致だから**  
3. **`fmt.Println` で複数の引数を与えれば、スペース区切りで表示されるので、もし別の変数を足しても簡単に出力できる**  
4. **`var name = 123` と書けば、暗黙の型推論で `name` が int となり、エラーなく `123` と出力するプログラムになる**

**解答**: **(2)**

**解説**:
- **(2) が正解**  
  - `name` は `string` 型で宣言されているため、整数リテラル `123` を代入すると**型不一致**でコンパイルエラー。Go は静的型付け言語なので、暗黙変換は行われません。
- (1) **再代入は可能**  
  - 部分的には正しいが、このコードの場合は「型が不一致」なのでエラーになる点の説明になっていません。
- (3) **`fmt.Println` で複数引数を与えるとスペース区切りで表示する**  
  - これ自体は Go の正しい特徴ですが、**本問の挙動（コンパイルエラー）**とは関係ありません。
- (4) **`var name = 123` と書けば…**  
  - 確かにそう書けば `name` が int になりエラーは出なくなるでしょうが、「今のコードがどうなるか？」の説明ではありません。本問に直接の回答にならない。

---

### Q3 (穴埋め)
**問題**: コード内で `x` に `10` を初期値として与える際、Go の短縮宣言 (`:=`) を使う。  
```go
func main() {
    _____
    fmt.Println(x) // 10
}
```
**解答例**:
```go
x := 10
```

**正解**: `x := 10`

**解説**:
- `x := 10` により「変数宣言」と「初期化」と「型推論 (int)」が同時に行われ、`x` は `int` 型で 10 を持ちます。関数スコープ内なら `:=` を使えますが、パッケージレベルでは使えない点は留意しましょう。

---

### Q4 (判断)
**問題**: Go で `const` に一度値を代入したら、その後変更できる？  
**解答**: **(B)**（変更不可）

**解説**:- `const` は**再代入不可能**です。コンパイル時に値が固定されるため、後から `constName = newValue` のように書くとエラーになります。変数なら変更できるが、定数はできません。

---

### Q5 (選択)
**問題**: Go の `if` 文に関する次の説明のうち、**最も適切なもの**はどれでしょうか。

1. **Go の `if` 文は、条件を `( )` で囲む必要があり、さらに一文だけのブロックなら `{ }` を省略できる**  
2. **Go の `if` 文では初期化文を書くことができるが、その場合は `;` で区切る必要がある**  
3. **Go の `if` 文では、`0` は `false`、それ以外の数値は `true` として扱われる**  
4. **Go の `if` 文では `( )` は必須ではなく、むしろ省略するのが一般的で、ブロックの括弧 `{ }` は常に必要である**

**解答**: **(4)**

**解説**:- **(4) が正解**: Go の公式スタイルでは `if x > 0 { ... }` のように**丸カッコを付けないのが一般的**です。一方で `{ }` は必須なので**ワンライナー**にして省略はできません。
- (1) は C/Java などの影響でそう思いがちですが、Go では `if` の条件式は `()` で囲む必要はありません。
- (2) Go言語の`if`文では初期化文を書くことができますが、`;` で区切る必要はありません。
- (3) 数値をブールに暗黙変換する仕組みは Go にありません。たとえば`if 1 {}` はコンパイルエラーです。

---

### Q6 (単純記述)
**問題**: `for i := 0; i < 5; i++ { ... }` は何回ループするか？  
**解答**: **5回**

**解説**:- `i` が 0 から始まり `i < 5` の間ループを回す → `i=0,1,2,3,4` の計5回。

---

### Q7 (穴埋め: switch)
**問題**: 
```go
switch x {
( A ) 1:
    fmt.Println("one")
( B ) 2:
    fmt.Println("two")
( C ):
    fmt.Println("other")
}
```
**解答例**:
- (A) → `case`
- (B) → `case`
- (C) → `default:`

完成:
```go
switch x {
case 1:
    fmt.Println("one")
case 2:
    fmt.Println("two")
default:
    fmt.Println("other")
}
```

- **解説**: Go の switch で case に当てはまらなければ `default` が実行される。
- `switch x { case 1: ... case 2: ... default: ... }` が典型的な形。
- `default:` 節は「上記以外の場合」という意味で、省略可能ですが、一般的には書いたほうが安全です。

---

### Q8 (選択)
**問題**: Go の整数型 `int` は、プラットフォームによって32ビット or 64ビットになる可能性があるが、その違いに一般的にどう対処するか？

1. **`int` は環境依存で32か64か決まるが、通常の数値演算では問題になりにくいのでそのまま使うことが多い**  
2. Go のコンパイラは整数演算をすべて 64 ビット幅として振る舞う  
3. 実行時に `int` のビット幅が動的に切り替わり、プログラム内でサイズが変化  
4. 複数アーキテクチャ対応のため、`int` はメモリ配置が2バイト刻みになる

**解答**: **(1)**

**解説**:
**なぜ `int` は環境依存？**

Go の仕様では、`int` はそのプラットフォーム（アーキテクチャと OS 組み合わせ）に応じて**32ビット幅または64ビット幅**になると定義されています。これは C 言語や他の静的型付け言語にも見られるアプローチで、

- **32ビット環境**では `int` が 32ビット（最大値約 2^31-1）  
- **64ビット環境**では `int` が 64ビット（最大値約 2^63-1）

となるため、ソースコード上は単に `int` と書いていても、ビルドするターゲットプラットフォーム次第でビット幅が変わる仕様です。

**(1) が正解の理由**

> **「`int` は環境依存で32か64か決まるが、通常の数値演算では問題になりにくいのでそのまま使うことが多い」**

- **現場での慣習**: Go の公式スタイルや一般的な Go コードでは、特に制限がない限り `int` を使うのが慣例です。典型的な業務ロジックやアルゴリズム実装では 2^31 や 2^63 の上限に引っかかるようなケースが少なく、当面 `int` で不足しないことが多いです。  
- **トラブルが少ない**: もし 64ビット以上の整数が必要な場面はごく限られ、しかもそのときは `int64` や `big.Int`(任意精度) を選ぶことが明確になります。逆にほとんどの 64ビット環境では `int` が 64ビットなので、数値演算のオーバーフローに困るシーンは稀です。

**他の選択肢の解説**

1. **(2)「Go のコンパイラは常に 64 ビット演算を行う」**  
   - 一見「64ビット環境ならそうかも」と思えますが、Go は 32ビット環境上では 32ビット幅として動作しますし、コンパイラが一律で 64ビット演算を使うわけではありません。  
   - 実装によっては命令セットや最適化の違いがあるが、「常に64ビット演算になる」わけではないので本問の最適解にはならない。

2. **(3)「実行時に `int` のビット幅が動的に切り替えられる」**  
   - Go の言語仕様で、ビルド時点でターゲット環境が決まります。実行中に動的にビット幅が変わるわけではありません。  
   - これは動的型付け言語であってもないような挙動。誤解を招く選択肢です。

3. **(4)「メモリ配置が2バイト刻みになるよう自動調整される」**  
   - これは他の言語や特定のアーキテクチャにおける特殊知識と混同している例。Go が `int` の配置を2バイト単位に調整するような仕組みは定義されていません。  
   - Go は基本的に 4バイト or 8バイト（32or64bit）幅が標準となるだけです。

**いつ `int32` / `int64` を使う？**

- **特殊要件**があるときに明示的に使います。例えばファイルサイズやタイムスタンプなど、64ビット固定で管理したい場合は `int64`。  
- API レベルで 32ビット確定のデータを扱う場合は `int32` を使うと混乱を回避できます。

---

### Q9 (穴埋め: 単答)
**問題**: Go は「______型付け言語」？  
**解答**: **静的型付け**（「静的型付け言語」）

- **解説**: 静的型付け言語 (Statically typed language) は、プログラムのコンパイル段階で型が決まり、不一致があればコンパイルエラーになります。

---

### Q10 (判断)
**問題**: `:=` はパッケージレベルでも同様に使えるか？  
**解答**: **(B) False**

- **解説**: `:=` は**関数スコープ**でのみ使える。パッケージレベル（グローバル）では `var x = ...` のような書き方が必要です。

---

## Level 2（中程度）

### Q11 (選択: スライスの len と cap)
**問題**:
```go
s := make([]int, 3, 5)
```
`len(s)` と `cap(s)` の値は？

**解答**: **(1) len=3, cap=5**

**解説**

**`len` (長さ) と `cap` (容量)**
- **長さ (`len`)**: 現在アクセス可能な要素数  
- **容量 (`cap`)**: スライスが再割り当てなしに使える最大要素数  

スライスは内部で「ポインタ・長さ・容量」を持ち、長さが `len`、容量が `cap` に対応します。初期生成時点で `len` が 3 ならインデックス `0,1,2` が使え、容量 5 は「あと 2 個ぶん要素を追加しても新たにメモリを割り当てなくて済む」という意味です。

**`make([]int, 3, 5)` の仕組み**
Go の `make` 関数は、**スライス/マップ/チャネル**といった参照型を生成する際に用いられます。  
```go
make([]T, length, capacity)
```
- 第2引数 (**length**) → スライスの初期長さ  
- 第3引数 (**capacity**) → スライスの容量 (任意指定しない場合は length = capacity)

本例 `make([]int, 3, 5)` は「長さ3、容量5」のスライスを作るため、

- `len(s) = 3`
- `cap(s) = 5`

という設定になります。

**選択肢の解説**
- **(1)** 逆に書いており誤り (`len=5, cap=3` はここでは正しくない)。  
- **(2)** 正解。`len=3, cap=5`。  
- **(3)** 長さ・容量は宣言直後に明確に定まるので「不定」ではありません。  
- **(4)** `make([]int, 3, 5)` は正しい文法でエラーになりません。


---

### Q12 (穴埋め)
**問題**: スライスに要素を追加する関数。  
```go
nums := []int{}
nums = _____(nums, 10)
nums = _____(nums, 20)
```
**解答**: **append**

```go
nums = append(nums, 10)
nums = append(nums, 20)
```

**解説**:- `append(slice, elem)` は Go のビルトイン関数で、スライス末尾に要素を追加し、新しいスライスを返す。

---

### Q13 (選択: マップの削除)
**問題**: Go のマップ `map[string]int` で、あるキー `"Alice"` を削除するにはどう書くか。

1. **`delete(m, "Alice")` を呼び出すと指定キーごとエントリを取り除ける**  
2. `m["Alice"] = 0` と代入すれば、Go ランタイムが“0 値”を検出し自動的にマップからキーを排除する  
3. `m = make(map[string]int)` と再生成するのが一般的で、不要キーだけ消す操作は無駄が多いので推奨されない  
4. Go のマップはイミュータブル（不変）構造なので、削除には一旦新しいマップを作って必要なキーのみコピーする  

**解答**: **(1)**

---

**解説**

**なぜ (1) が正解か**

- Go には**ビルトイン関数** `delete(マップ, キー)` があり、**そのキーに対応する要素を完全に取り除く**機能を担います。  
- 具体例:  
  ```go
  m := map[string]int{"Alice": 100, "Bob": 200}
  delete(m, "Alice")
  // これで "Alice" キーは完全に消え、 m["Alice"] は存在しなくなる
  ```
- この操作により `m` の中から `"Alice"` が確実に削除され、後で `m["Alice"]` を読み込むと要素が存在しないと判定されます。

**他の選択肢の解説**

1. **(1) `delete(m, "Alice")`**  
   - **本問の正解**。Go で部分的にキーを消す場合の正式な方法。

2. **(2) `m["Alice"] = 0` と代入すれば…**  
   - 値を `0` にするだけで、キー自体は残ります。Go には「0 値を見て自動削除」する仕組みがありません。  
   - したがってこのやり方は、削除ではなく「キーの値を 0 に上書き」するだけです。

3. **(3) `m = make(map[string]int)` と再生成…**  
   - これを行うと **すべて** のキーが消えてしまうため、「特定のキーだけを取り除く」目的にそぐいません。  
   - あるキーだけを消したいなら `delete(m, "Alice")` が最適。  
   - 場合によっては「全削除」が必要なら再生成も一案ですが、「不要キーだけ消す操作が無駄が多い」というのは誤解です。

4. **(4) Go のマップはイミュータブルなので…**  
   - Go のマップは**可変（ミュータブル）**です。イミュータブルではありません。  
   - 一時的に新しいマップを作り直す方法も可能ですが、まったく必須ではありません。

**補足: `delete` の使い方と注意点**

- **書式**: `delete(マップ, キー)`  
- **キーが存在しない場合**: 何も起きずエラーにもなりません。つまり “安全に” 呼べます。  
- **キーが存在する場合**: そのエントリが取り除かれます。  
- **マップが nil の場合**: `delete(nil, "Alice")` はランタイムエラーにはならず、単に無視されます。  
  - とはいえ、nil マップは通常読み書きがエラーになる点に注意が必要です。

---

### Q14 (選択: nil マップ)
**問題**: 次のマップ宣言で、`myMap` が `nil` になるケースはどれか。

1. `var myMap map[string]int` だけで初期化しないと、nil マップになる  
2. `myMap = make(map[string]int)` と書いても、最初の代入時に内部的に nil チェックが行われて実体化されないことがある  
3. Go では `map[string]int{}` を書いてもマップ本体が遅延評価されるので、アクセスするまで実態がnilとして扱われる  
4. 宣言のしかたに関係なく、Go のマップはどのタイミングでも書き込み可能なので nil チェックは不要  

**解答**: **(1)**

**解説**
**nil マップの宣言**
- **(1) が正解**: Go では `var myMap map[string]int` と宣言した場合、**初期化を行わない**ため内部的には `nil` が割り当てられます。  
  - たとえば以下のように書いた場合:
    ```go
    var myMap map[string]int
    // myMap は nil
    fmt.Println(myMap == nil) // true
    ```
  - この状態で `myMap["Alice"] = 100` のように書くと、**ランタイムエラー**（panic）が起きます。

**他の選択肢**

1. **`myMap = make(map[string]int)`**  
   - `make(...)` によりマップが**実体化**されるので、nil ではなく空のマップになる。`myMap["Alice"] = 100` も正常に動作します。

2. **`map[string]int{}`**  
   - これも**リテラルによる初期化**であり、nil ではなく空のマップ（キーなし）を作ります。したがって書き込み可能です。

3. **マップはどのタイミングでも書き込み可能なので nil チェック不要**  
   - Go のマップは可変ですが、**nil のまま書き込むとエラー**になります。必ず `make` やリテラル生成などで実体化が必要です。

**nil マップに関する注意点**

- **nil のマップ**と**空のマップ**は見た目は同じようにキーが存在しない状態でも大きく異なり、nil マップに書き込みしようとすると `panic` が発生します。  
- 一方、nil マップを **読み込み**（例えば `val := myMap["Alice"]`）する行為はエラーなく行え、ゼロ値（intなら0）が返ります。このあたりが “書き込みはエラー、読み込みはゼロ値を返す” という挙動として混乱しやすいポイントです。

---

### Q15 (選択: 複数戻り値 `(int, error)` の理由)
**問題**: 以下の関数宣言において、戻り値が `(int, error)` になっているのはなぜか。

```go
func doSomething(a, b int) (int, error) {
    // 中略
}
```

1. Go では複数の戻り値を返せるため、正常結果とエラーを同時に返すのがよくあるスタイル  
2. `error` は暗黙的に `int` と互換性があり、0 ならエラー無し、負数なら警告、正数なら致命的エラーを表す  
3. カンマ区切りで書く戻り値は、実は引数として渡される仕組みであり、最後にまとめて処理される  
4. Go ではエラーを返す場合でも `panic` が実行されるため、実質 `(int, error)` はダミー定義に近い  

**解答**: **(1)**  
**解説**
1. **Go は複数の戻り値を返すことができる**  
   - Go 言語は他言語のように「戻り値は1つだけ」ではなく、`(T, error)` のように複数の値を返せるのが特徴です。これにより正常結果 (`int` など) とエラー (`error`) をペアで返す習慣が広く浸透しています。  
   - これが**本問の答え**。「よくあるスタイル」というのは、Go の**エラーを例外としてスローせず、戻り値として明示する**という設計思想が背景にあります。

2. **(2) `error` と `int` が互換性を持つ**  
   - こうしたルールは Go にありません。`error` はあくまでインターフェース型（`type error interface { Error() string }`）であり、数値的に解釈する仕組みはありません。  
   - C言語などで「0=成功、1=失敗」と返す慣習と混同している選択肢です。

3. **(3) カンマ区切りの戻り値は引数として渡される**  
   - Go では実行時に「戻り値を別関数に渡す」場合、明示的に呼び出しを組み合わせなければ自動的には行われません。たとえば `f(g())` のように書けば `(x, y)` が `g()` の戻り値として渡されるが、それはあくまで呼び出し側の書き方次第です。  
   - カンマ区切りで書かれた戻り値は**「複数の値として同時に返す」**という仕組みであり、本問の核心的な回答になりません。

4. **(4) 「エラーを返す場合でも `panic` が実行される」**  
   - Go では通常「エラー時は `panic` する」のではなく、「エラー値(`error`)を返す」手法が推奨されます。  
   - もちろん致命的な状況で `panic` を使うこともありますが、**すべてのエラーが `panic` になるわけではなく**、大半は `(T, error)` の戻り値でハンドリングします。

**Go のエラー処理における `(result, error)`**
- **スローとキャッチ(Exception) ではなく**、関数の戻り値としてエラーを返すのが Go の基本設計。  
- 呼び出し側は `x, err := doSomething(a, b)` と受け取り、`if err != nil { ... }` で分岐処理を行う。  
- これにより、**エラー確認を強制**しやすくなり、ソースコード上も「いつエラーが発生しうるか」が明示的です。

---

### Q16 (穴埋め: sumSlice)
```go
func sumSlice(nums []int) int {
    total := 0
    for __, val := range nums {
        total += val
    }
    return total
}
```
**解答**:  
```go
for _, val := range nums {
    total += val
}
```
- **解説**: range スライスで `for _, val := range nums`。

---

### Q17 (穴埋め: 複数戻り値のシンタックス)
**問題**: Go で**複数の戻り値**を返す関数を書くとき、どのようなシンタックスを使うか。

**回答**: `func sample(x int) (int, bool) { ... }`

**解説**:- `(type1, type2, ...)` の形で複数の戻り値を並べられるのが Go の大きな特徴。 

---

### Q18 (選択: Go のテストファイル)
**問題**: Go のテスト (`go test`) でテスト関数を書く際の命名規則は何か。

1. テストファイル名を `test_???_go` とし、関数名は何でもよい  
2. `main.go` の中に `func testMain()` を書けば自動的にテストされる  
3. テストファイル名を `_test.go` とし、関数名を `TestXxx(t *testing.T)` の形にしなければならない  
4. Go では標準テスト機能が無い

**解答**: **(3)**

**解説**
**Go の標準テストフレームワーク**
Go には、標準パッケージとして **`testing`** が用意されており、`go test` コマンドを使って自動的にテストを実行できます。追加の外部ライブラリを必要とせず、**標準でユニットテストや簡易ベンチマーク、例示的テスト**などが可能です。

**テストファイルの命名規則**
- **「ファイル名を `_test.go` で終わらせる」**  
  - たとえば `calc_test.go`, `stringutil_test.go` のように書きます。  
  - これにより、`go test` がテストファイルとして自動認識し、コンパイル＆実行に組み込みます。

**テスト関数の命名規則**
- **「関数名を `TestXxx(t *testing.T)` の形にする」**  
  - `Xxx` には任意の識別子を付け、例えば `TestAdd`, `TestSomething` のように書くと、`go test` が「この関数はテスト関数だ」と認識。  
  - 関数のシグネチャは必ず引数に `*testing.T` を取り、戻り値なし (`func TestXxx(t *testing.T)`) とする必要があります。

**他の選択肢が誤り・不十分な理由**
1. **(1) 「ファイル名を `test_???_go` とし、関数名は何でもよい」**  
   - 実際には `test_???_go` ではテストファイルとして認識されません。正式には `_test.go` のサフィックスが必要ですし、関数名も `TestXxx` としなければ `go test` はテストとして扱いません。

2. **(2) 「`main.go` の中に `func testMain()` を書けば自動テストされる」**  
   - こうした仕組みはありません。`main.go` そのものは通常アプリのエントリーポイントであり、`testMain()` という特別な関数は存在しません。

3. **(4) 「Go では標準テスト機能が無い」**  
   - 誤り。Go には標準のテスト機能 (`testing` パッケージ、`go test`) があり、追加のライブラリなしでユニットテストを実行できます。

---

### Q19 (選択: スライスの部分範囲)
**問題**:`s := []int{10, 20, 30, 40, 50}` とし、`sub := s[1:4]` とした場合、`sub` は何を指すか。

1. `[10,20,30]`  
2. `[20,30,40]`  
3. `[30,40,50]`  
4. `[10,20,30,40]`

**解答**: **(2)**

- **解説**:
**スライスの部分範囲**
- `s[1:4]` は「`s` のインデックス 1 から 4 未満まで」を指す。つまり `s[1], s[2], s[3]` が含まれる。したがって `sub` は `[20,30,40]` となります。

---

### Q20 (判断: マップ追加・更新)
**問題**: Go のマップにおいて、キーを追加・更新する操作 `m[key] = value` は同じ書き方で行える。

- (A) Yes  
- (B) No  

**解答**: **(A)**

**解説**:- もし `key` が存在しなければ**追加**、存在すれば**上書き**。同じ構文で両方できる点は Go のマップの特徴です。

---

## Level 3（中級～やや上級入り口）

### Q21 (選択: 構造体とは)
**問題**: Go の構造体 (struct) について、正しい説明はどれか。

1. `type Person struct { Name string; Age int }` のように、複数のフィールドをひとまとめにできる  
2. Go の構造体はコンパイル時にクラスへ変換され、すべてのフィールドにコンストラクタが自動生成される  
3. フィールド名をすべて大文字にしないと、同じパッケージ内でも構造体のメモリ領域にアクセスできない  
4. 構造体のフィールドにスライスを入れるときは別途 `makeStructSlice(...)` を呼び出すため、標準型を直接使えない  

**解答**: **(1)**

**解説**
1. **(1) が正解**  
   - Go の構造体は、関連する複数のフィールドをまとめるためのカスタム型。  
   - 例えば `type Person struct { Name string; Age int }` のように書けば、`Person` という新しい型ができ、`Name` と `Age` の2つのフィールドをまとめて扱えます。  
   - 構造体そのものに“クラス”のような継承機能はありませんが、メソッドを定義して使うことは可能です（`func (p Person) SomeMethod() { ... }` 等）。

2. **(2) 「コンパイル時にクラスへ変換+自動コンストラクタ」**  
   - Go に“クラス”という概念はありません。構造体はそのまま低レベルにメモリレイアウト(データがメモリの中でどの順番・位置に並ぶかを決める)され、コンストラクタは自動生成されません（必要なら手動で初期化関数を書く）。

3. **(3) 「すべて大文字にしないと同パッケージ内でアクセスできない」**  
   - Go では大文字/小文字が**エクスポート（パッケージ外公開）**を決定します。同じパッケージ内であれば、小文字フィールドでも自由にアクセス可能。  
   - 大文字にしなければ外部からは見えませんが、同パッケージ内では問題ありません。

4. **(4) 「フィールドにスライスを入れるときは `makeStructSlice(...)` が必要」**  
   - Go で構造体のフィールドにスライスを持たせる場合は、単に `[]T` フィールドを宣言し、必要に応じて `make` やスライスリテラルで初期化すればOK。`makeStructSlice(...)` という特別な関数は存在しません。  
   - 例えば:
     ```go
     type Person struct {
         Friends []string
     }
     p := Person{ Friends: []string{"Bob","Carol"} }
     ```
     などとすれば問題なく使えます。

---

### Q22 (選択: 値レシーバとポインタレシーバ)
**問題**: 以下のメソッド宣言で `(p Person)` と `(p *Person)` が異なる理由は何か。

```go
func (p Person) ChangeName(newName string) {
    p.Name = newName
}
func (p *Person) UpdateAge(newAge int) {
    p.Age = newAge
}
```

1. 値レシーバでは構造体のコピーを操作し、ポインタレシーバならオリジナルを更新できる  
2. ポインタレシーバは内部的にメモリマップを直接いじるため、一度でも `nil` が入ると二度と再利用できなくなる  
3. 値レシーバでメソッドを書くと、メソッド呼び出し中にガーベッジコレクタが動いても安全だが、ポインタだと危険  
4. 動作結果は同じだがコンパイラが選択する命令セットが異なり、最適化の都合でポインタレシーバの方が数倍遅い  

**解答**: **(1)**

**解説**
**レシーバの値・ポインタ**
Go では、構造体メソッドのレシーバを「値」か「ポインタ」で受け取るかを選べます。
- **値レシーバ `(p Person)`**  
  - メソッド内で `p` は**構造体のコピー**。  
  - `p.Name = newName` のように書いても、呼び出し元の変数には反映されません（コピーを操作しているだけ）。
- **ポインタレシーバ `(p *Person)`**  
  - メソッド内で `p` は構造体へのポインタ（実体を指すアドレス）  
  - `p.Name = newName` のように書くと、呼び出し元の実体を**直接変更**できる。

**なぜ (1) が正解か**
> **「値レシーバでは構造体のコピーを操作し、ポインタレシーバならオリジナルを更新できる」**
- **値レシーバ**は**コピー**を操作するため、元の構造体には影響を与えません。
- **ポインタレシーバ**は**元の構造体**を直接操作するため、呼び出し元の変数にも反映されます。
- このため、値レシーバ`(p Person)`は「コピーを操作する」、ポインタレシーバ`(p *Person)`は「元の構造体を直接操作する」という違いがあります。

**他の選択肢**
1. **(2)「ポインタレシーバは内部的にメモリマップを直接いじるため…」**  
   - 確かにポインタはアドレスを持ちますが、「一度 nil が入ると二度と再利用できない」などは誤解。`nil` ポインタなら `p == nil` 判定など行えますし、別の実体を再度代入すれば使えます。
2. **(3)「値レシーバなら GC が動いても安全、ポインタなら危険」**  
   - Go のガーベッジコレクタはポインタを追跡できますし、通常は危険ではありません。ポインタレシーバだから GC が絡んで危険になるわけではありません。
3. **(4)「動作結果は同じで、コンパイラの命令セットが違う」**  
   - 動作結果は明確に異なります。値レシーバはコピーを変更、ポインタレシーバは元のインスタンスを変更します。コンパイラの最適化による速度差も一概には言えません。
---

### Q23 (穴埋め: メソッド)
```go
func (r *Rect) (A)(w int, h int) {
    r.Width = w
    r.Height = h
}
```
**解答例**: `Resize`

- **解説**: 任意の名前だが、意味の通る名称をつける。レシーバが `*Rect` なので、呼び出し元の `Width/Height` を変えられるメソッド。

---

### Q24 (選択: ゴルーチン起動)
**解答**: **(2) `go` キーワード**

- **解説**: `go funcName(...)` と書くと、その関数を並行に起動するゴルーチンとなる。

---

### Q25 (選択: インターフェースの実装)
**問題**: Go のインターフェースはどのように実装が判断されるか。

1. 明示的に `implements InterfaceName` と書く  
2. 構造体が「インターフェースが要求するメソッドを全て持っていれば」暗黙的に実装とみなされる  
3. `interface{}` は何でも受け取れるが実装判定はできない  
4. インターフェースはJavaやC#だけにある概念で、Goには存在しない  

**解答**: **(2)**

**解説**
1. **Go の「暗黙の実装方式」**
   - Go のインターフェースは、**“インターフェースが要求するメソッドを型が全部持っていれば、その型はそのインターフェースを実装している”** とみなされます。  
   - たとえば `io.Writer` インターフェースは `Write(p []byte) (n int, err error)` メソッドを要求しますが、型がこのメソッドを持っているなら、特に宣言しなくても自動的に「`io.Writer` を実装している」と認識されます。
   - これを **「暗黙の実装（implicit implementation）」** あるいは **「structural typing」** と呼び、Java や C# のような「implements」キーワードを用いる“明示的実装”とは対照的です。
2. **(2) が正解**
   - **(2)** は **「構造体がインターフェースが要求するメソッドをすべて持っていれば暗黙的に実装とみなされる」** という、Go のインターフェース実装法を正しく表しています。
3. 他の選択肢
   - **(1)「明示的に `implements InterfaceName` と書く」**  
     - 他言語(Java/C#)では見られる構文ですが、**Go には存在しません**。  
   - **(3)「`interface{}` は何でも受け取れるが実装判定はできない」**  
     - `interface{}` (空インターフェース) は「任意の型を代入可能」という特徴がありますが、実際には“すべての型が自動的に実装している”とも言えます。とはいえ「実装判定できない」という表現は誤解を招きます。むしろ “メソッド要件がない” ため、あらゆる型を受け入れるのが空インターフェースです。
   - **(4)「インターフェースはJavaやC#だけにある概念で、Goには存在しない」**  
     - Go には**独自のインターフェース**が存在し、本問の核心である「暗黙の実装」という大きな特徴があります。よって明らかに誤りです。

---

### Q26 (単純回答: `error`型)
**問題**: `error`型は何を表すためのもの？  
**解答例**: 「関数や処理が失敗した理由やエラー状態を表すために使う型」

- **解説**: Go は例外ではなく `(T, error)` の形式でエラーを返す設計。

---

### Q27 (選択: チャネル受信)
**問題**: 以下の並行処理コードで、チャネル `results` が `make(chan string)` として作られている。正しい説明はどれか。

```go
msg := <- results
```

1. **これは受信ブロックを表し、`results` から文字列が送られてくるまで待つ**  
2. これは送信ブロックを表し、msg が入るまで待つ  
3. Go では `<-` 演算子は存在しない  
4. これはデッドロックを必ず起こす  

**解答**: **(1)**

**解説**
1. **Go のチャネルと `<-` 演算子**
   - Go では、チャネルを使ってゴルーチン間でデータを送受信します。書き方は以下の通りです:  
     - **送信**: `results <- "some string"`  
     - **受信**: `value := <-results`
   - 受信側のコード `value := <-ch` は、**チャネル `ch` から値が届くまで待機**する（ブロックする）仕組みです。
2. **(1) が正解**  
   - `msg := <- results` は**受信操作**です。`results` に誰かが `results <- "someData"` と送信するまで待ち、その送られた文字列を `msg` に格納します。
3. 他の選択肢
   - **(2)「これは送信ブロック」**  
     - 送信ブロックは `results <- something` の形。`<- results` は受信。
   - **(3)「Go では `<-` 演算子は存在しない」**  
     - Go の並行処理では `<-` は必須。実際に存在します。
   - **(4)「これはデッドロックを必ず起こす」**  
     - 必ずではありません。送信するゴルーチンがいれば正常に動作します。デッドロックになるかどうかは送信側の実装やチャンネルバッファ状況次第です。

---

### Q28 (穴埋め: ゴルーチンで sayHello)
```go
go sayHello()
```
- **解説**: ゴルーチン起動キーワードは `go`。

---

### Q29 (判断: メソッドのレシーバは任意の型)
**問題**: Go のメソッドは、構造体だけでなく任意の型（例えば `type MyInt int`）に対しても定義できる。

**解答**: **(A)**

**解説**
Go では、**自分で定義した型**（たとえば `type MyInt int`）に対してもメソッドを定義できます。構造体だけが対象ではありません。以下のように書けます:

```go
type MyInt int

func (m MyInt) Double() MyInt {
    return m * 2
}
```

これにより、`MyInt(5).Double()` のように呼び出すと、`10` が返ります。ただし、**組み込み型 (int, string など) を直接拡張する**わけではなく、**自分で定義した型の別名**として宣言したもの（`type MyInt int` など）であればメソッドを持たせられる、という仕組みです。

---

### Q30 (短答: 複数戻り値 `(result, error)` の設計意図)
**解答例**:
- 「例外をスローせず、`(T, error)` の戻り値によって明示的にエラーを扱うため。」

- **解説**: Go は `panic` もあるが通常は非推奨。エラーの多くは `(normalResult, err)` の形で返し、呼び出し元が `if err != nil` を明示的に書く設計が主流。

---

## **Level 4 (Q31～Q40)**

### Q31 (選択: `select` で複数チャネル待ち)
以下のコードは複数のチャネルを同時に待つために書かれています。どの構文が正しいか？

```go
select {
( A )
    fmt.Println("got from dataCh:", v)
( B )
    fmt.Println("timeout!")
}
```

1. (A) `case v := <-dataCh:` 、 (B) `case <-time.After(5 * time.Second):`  
2. (A) `v := <-dataCh:` 、 (B) `<-time.After(5 * time.Second):`  
3. (A) `case dataCh-> v:` 、 (B) `case timeout:`  
4. (A) `if dataCh != nil` 、 (B) `default:`  

**解答**: **(1)**

**解説**
1. **正しい `select` 文の基本**
- Go で複数チャネルを同時に待つ典型的パターンは、以下のように**各行に `case` キーワード**と**送受信演算子**を明示します。
    ```go
    select {
    case v := <-dataCh:
        // dataCh から受信
        fmt.Println("got from dataCh:", v)
    case <-time.After(5 * time.Second):
        // 5秒経過でタイムアウト
        fmt.Println("timeout!")
    }
    ```
- **`case v := <-dataCh:`** → `dataCh` から受信。変数 `v` に格納。  
- **`case <-time.After(5 * time.Second):`** → 5秒後にシグナルが届くチャネルを待ち受ける（タイムアウト処理）。
2. **(1) が正解**
  - (A) `case v := <-dataCh:` は**典型的な受信パターン**に合致。(B) も `case <- time.After(5 * time.Second):` は**典型的なタイムアウト処理**の書き方です。

**他の選択肢**
**(2)**
- **問題点**:  
  - ここでは (A) `v := <-dataCh:` に **`case` キーワードが無い**。`select` 文の中では `case ...:` が必須なので文法的に成立しません。  
  - (B) も同様に `<-time.After(5 * time.Second):` だけで `case` がないので正しい受信表現にもなっていません。

**(3)**
- **問題点**:  
  - `dataCh-> v` は Go には存在しない文法（C++ や他言語とも違う誤記）。Go での受信は `v := <-dataCh` か `<-dataCh`。  
  - `case timeout:` もタイムアウトの仕組みが具体的に書かれていないし、`timeout` がどんなチャネルか不明。  
  - これも Go の文法として誤りが多い。

**(4)**
- **問題点**:  
  - `select` 文の中に `if dataCh != nil` という条件を直接書くことはできず、**`case` 節でのチャネル操作**が目的なのに逸脱している。  
  - `default:` はフォールバック節として使える場合があるが、この問題で「複数チャネルを同時に待つ」実装として正しくない。

**ワンポイント: `<-time.After(...)` の意義**
- **`time.After(d)`** は「`d` 時間後にシグナルを送るチャネル」を返します。  
- **`case <-time.After(d):`** と書くことで「指定時間後に実行される」タイムアウト処理を追加するのが典型的です。

---

### Q32 (選択: WaitGroup)
**問題**: Go の並行処理で「WaitGroup」を使う目的は何か？

1. すべてのゴルーチンが終了するまでメイン関数が終わらないようにするため  
2. ゴルーチンを終了強制するため  
3. “シングルトン”パターンを実装するため  
4. `select` 構文で使わないとコンパイルエラーになる  

**解答**: **(1)**
**解説**
**(1) が正解**  
   - **WaitGroup** は、起動したゴルーチンの数をカウントし、それらが全部終了するのを待ってからプログラムを先に進めるための仕組みです。  
   - 典型的には以下のように使います：
     ```go
     var wg sync.WaitGroup
     
     wg.Add(1)
     go func() {
         defer wg.Done()
         // 何らかの処理
     }()
     
     wg.Wait() // ここでゴルーチンが終了するのを待つ
     ```
   - メイン関数で `wg.Wait()` を呼べば、**すべてのゴルーチンが終わるまでメイン関数が終了しない**よう制御できます。
**(2)「ゴルーチンを終了強制するため」**  
   - WaitGroup は終了を**強制する**仕組みではありません。ゴルーチン内で `Done()` を呼んでもらうのを待つだけなので、「強制終了」はできません。
**(3)「“シングルトン”パターンを実装するため」**  
   - WaitGroup は並行処理の“待ち合わせ”に使う機能であり、デザインパターンとしてのシングルトンを実装するための機構ではありません。
**(4)「`select` 構文で使わないとコンパイルエラーになる」**  
   - WaitGroup は `select` とはまったく無関係で、**単独**で使用できます。`select` を用いなくても WaitGroup は問題なく動作します。

---

### Q33 (記述: デッドロック修正)

**問題 (再掲)**: コード補足付きの「URLの数だけ送信するのに1回しか受信していない」バグ。  
**解答例**:

- **回答**: 「`len(urls)` 回だけ `res := <- results` を行う（ループで3回受信）すればOK」  
  - 例:  
    ```go
    for i := 0; i < len(urls); i++ {
        res := <-results
        fmt.Println(res)
    }
    ```  
  - または `WaitGroup` を使ってゴルーチンが終わるのを待つ方法なども考えられるが、単純には「送信分だけ受信する」ロジックが大切。

**解説**:  
- ゴルーチンが3回 `results <- ...` を行うなら、メイン側も3回 `<-results` しなければチャネルが詰まり、デッドロックになる。

---

### Q34 (穴埋め: context)

**問題 (再掲)**:
```go
func work(ctx context.Context) {
    for {
        select {
        case <- (A):
            return
        default:
            // 作業を続行
        }
    }
}
```

**解答**: **(A) `ctx.Done()`**

**解説**:  
- `ctx.Done()` は「キャンセルやタイムアウトが通知されるチャネル」。`case <-ctx.Done(): return` としておけば、キャンセル時にループを抜けられる。

---

### Q35 (選択: ジェネリクス基礎)
**問題**: 以下のジェネリック関数がコンパイルエラーになる理由は？

```go
func max[T any](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

1. `any` はあらゆる型を受け取れるが、`>` 演算子が使える型とは限らないためコンパイルエラー  
2. Go のジェネリクスはすべて数値比較が可能な仕様なので、本来 `a > b` は許されるが `return b` が未定義になる  
3. `T` がインターフェースの場合は比較できず、具体型の場合のみ比較できるがコンパイラは型を判定しない  
4. ジェネリクスを使うときは `map[T]T` のような構文を必ず書く必要があるので、この例は誤用  

**解答**: **(1)**

**解説**
**(1) が正解**
   - **`any`** は「どんな型でも受け付ける」制約ですが、Go のコンパイラは「`any` と書かれた型 `T` が `>` 演算子をサポートするとは限らない」と判断し、**このコードをコンパイルエラーにします**。  
   - もし実際に数値や文字列など “比較可能” な型だけを想定するなら、`constraints.Ordered` や独自の型制約を使う必要があります。  
   - たとえば以下のようにすればコンパイルが通る（`constraints.Ordered` は数値や文字列など `>` が使える型を意味する）:
     ```go
     import "golang.org/x/exp/constraints"

     func maxVal[T constraints.Ordered](x, y T) T {
         if x > y {
             return x
         }
         return y
     }
     ```
**(2) 「Go のジェネリクスはすべて数値比較が可能」**
   - 誤りです。Go 1.18 以降のジェネリクスでも、特定の型制約なしに `>` を使えない。`any` は “あらゆる型” なので演算子を保証しません。
**(3) 「`T` がインターフェースの場合は比較不可…コンパイラは型を判定しない」**
   - 型推論を行うが、`any`(=`interface{}`) は演算子をサポートせず、単に「コンパイラが型を判断しない」わけではありません。誤解が混ざっています。
**(4) 「ジェネリクスで `map[T]T` のような構文が必須」**
   - Go ジェネリクスに `map[T]T` のような記述を必ず書く必要はありません。何らかの型パラメータを受ける関数や構造体を定義するときに、この形が必須というわけではない。

---

### Q36 (穴埋め: constraints.Ordered)

**問題 (再掲)**:
```go
func maxVal[T (B)](x, y T) T {
    if x > y {
        return x
    }
    return y
}
```
**解答**: **(B) → `constraints.Ordered`**

**解説**:
- `constraints.Ordered` は「大小比較が可能な型」を表す制約。`T` が `constraints.Ordered` なら `x > y` がコンパイル通る。
- Goでは型パラメータ `T` に制約を課すことができ、`[T 任意の型]` と書くことで `T` に対して任意の型を受け入れるという制約を設けることができます。
**例:**
```go
func maxVal[T constraints.Ordered](x, y T) T {
    if x > y {
        return x
    }
    return y
}
```
- このように `constraints.Ordered` を使うことで、`T` が大小比較可能な型であることを保証できます。

---

### Q37 (選択: カスタム制約)
**問題**: Go で自作の制約 (constraint) を定義する場合の書き方は？

1. `type MyConstraint interface { ~int|~float64 }` のようにインターフェースで定義  
2. constraints は標準ライブラリのみでカスタム不可  
3. constraintを作るには `constraint MyConstraint = "T"` と書く  
4. ジェネリクスで制約は使わない  

**解答**: **(1)**

**解説**
**(1) が正解**  
   - Go 1.18 以降、ジェネリクスを使うときに「型パラメータがどんな型を受け入れられるか」を制約 (constraint) として宣言可能です。  
   - 例えば、以下のように書くと「`~int` や `~float64` の底型を持つ型」をまとめて受け入れるコンストレイント (カスタム制約) を定義できます:
     ```go
     type MyConstraint interface {
         ~int | ~float64
     }
     ```
   - こうした“型セット”表記 (`~int|~float64`) は「この制約を満たす型パラメータ T は、底型が int か float64 に“近い”型（例: `type MyInt int` など）を受け入れる」という意味になります。  
**(2) 「constraints は標準ライブラリのみでカスタム不可」**  
   - 誤りです。Go は自前のインターフェースで独自制約 (`type MyConstraint interface {...}`) を書くことができます。  
   - ただし標準ライブラリにも `constraints.Ordered` などが用意されており、よく使われます。
**(3) 「constraintを作るには `constraint MyConstraint = "T"` と書く」**  
   - こういった書式は Go にはありません。Go では通常、`type MyConstraint interface { ... }` の形で制約を宣言します。
**(4) 「ジェネリクスで制約は使わない」**  
   - 実際には、ジェネリクスで演算子やメソッドを使いたい場合に**制約が重要**です。まったく制約を使わないと、`any` のように汎用型になりますが、`>` 演算子などは使えません。  
   - 演算子や特定メソッドを利用する場合は「どんな型がその演算やメソッドをサポートするか」明示するために制約が不可欠となります。

---

### Q38 (記述: ラップエラー `%w`)

**問題**: `fmt.Errorf("wrap: %w", err)` で元のエラーを包む利点を1行で述べる。

**解答例**:  
- 「上位レイヤーで `errors.Is` / `errors.As` を使って、包まれた元エラーを判定できるようになる。」

**解説**:  
- `%w` でラップする → `errors.Is` / `errors.As` により原因となるエラーを遡って調べられる。
- 例えば `fmt.Errorf("wrap: %w", err)` でエラーをラップすると、`errors.Is(err, targetErr)` で `targetErr` が包まれているか調べられる。

---

### Q39 (穴埋め: sync.Mutex)

```go
var mu sync.Mutex
var count int

func increment() {
    mu.(C)()
    count++
    mu.(D)()
}
```

**解答**:  
- (C) → `Lock`  
- (D) → `Unlock`

```go
mu.Lock()
count++
mu.Unlock()
```

---

### Q40 (選択: `select` + `default:`)
**問題**: 並行処理で `select` 文に `default:` 節を入れるとどうなるか？
1. `default:` がある場合、チャネルが準備されていなくても即座に抜けられるためブロックを回避できる  
2. `default:` を書くとすべてのチャネル受信が無効化され、次のコード行に強制ジャンプが行われる  
3. `select` が並行に複数の受信を待てなくなるので、必ずひとつのチャネルしか扱えない構造になる  
4. `default` はswitch文専用のキーワードなので、`select` で使うとコンパイルエラーになる

**解答**: **(1)**

**解説**
**(1) が正解**  
   - Go の `select` 文で `default:` 節を設けると、ほかの `case` がどれも「準備できていない」場合でも**すぐに `default:` 節が実行**され、ブロックを回避できます。  
   - 例えば以下の例:
     ```go
     select {
     case msg := <-ch:
         fmt.Println("received:", msg)
     default:
         fmt.Println("no message ready, continue immediately")
     }
     ```
     ここで `ch` に送信されていない・受信の準備ができていないなら、即座に `default:` が実行され、ブロックせず次に進みます。
**(2)「`default:` を書くとすべてのチャネル受信が無効化される」**  
   - 誤り。**もし `case` がすぐに読み取れるデータを持っている**場合、そちらが選ばれます。複数の `case` が準備完了なら擬似ランダムに選ばれる。  
   - すべて準備できていない場合にのみ `default:` が実行される、という仕組みです。
**(3)「`select` が並行に複数の受信を待てなくなる」**  
   - `default:` を設けても、「並行に複数のチャネルを待つ」こと自体は可能です。  
   - ただし、**すべての `case` がブロックする状態**の場合に `default:` がすぐ走り、ブロックせず進むだけです。
**(4)「`default` は switch 文専用なので select で使うとエラー」**  
   - Go では `switch` 文でも `default:` を使いますが、**`select` 文**にも `default:` 節を置けます。コンパイルエラーにはなりません。

---

## **Level 5 (Q41～Q50)**

### Q41 (選択: net/http)

```go
http.HandleFunc("/", handler)
____.ListenAndServe(":8080", nil)
```

**解答**: `http.ListenAndServe(":8080", nil)`

**解説**:  
- Go の最小Webサーバは `http.HandleFunc` でハンドラ登録後、`http.ListenAndServe`。ハンドラは `nil` でデフォルトのServeMuxを使う。

---

### Q42 (選択: ハンドラのシグネチャ)
**問題**: `http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {...})` の引数 `w` と `r` は何？

1. `w` と `r` はポインタ同士を相互に参照する循環構造で、実際の読み書きはすべて内部バッファが行う  
2. `r` はサーバー設定の構造体で、`w` はリクエストの中身を読み取るためのストリーム  
3. `w` はレスポンス用の Writer、`r` はクライアントからのリクエスト情報を持つ  
4. `w` はリクエスト用の Writer、`r` はクライアントへのレスポンス情報を持つ  

**解答**: **(3)**

**解説**
**Go のハンドラ関数シグネチャ**
   - `http.HandleFunc(pattern string, handler func(w http.ResponseWriter, r *http.Request))`
   - このシグネチャにある `w` と `r` は、**`w` がレスポンスを書き込むため** (`ResponseWriter` インターフェース)、**`r` がリクエスト情報を表す構造体** (`*http.Request`) という役割です。
**(3) が正解**
   - 「`w` はレスポンス用の Writer（書き込み先）、`r` はクライアントのリクエスト内容を保持する構造体」というのが最も正しい説明です。
   - 実際、`w.Write([]byte("Hello"))` などとすると、サーバがクライアントへレスポンスデータを送信できます。一方 `r.URL` や `r.Method`、`r.Header` などで、リクエストの詳細を取得します。
**他の選択肢**
   - **(1)** 「ポインタ同士が循環構造」：そんな仕組みではありません。`w` と `r` は別々のオブジェクトであり、相互に参照し合う関係ではありません。  
   - **(2)** `r` はサーバー設定ではなく**リクエスト**そのもの。`w` はリクエストの中身を読むのではなく、レスポンスを書き出す側。  
   - **(4)** も真逆。「`w` はリクエスト用 Writer」ではなく、`w` は**レスポンス**側です。

---

### Q43 (穴埋め: Go module)

```bash
cd myproject
___ init example.com/myproject
```

**解答**: **`go`**  

```bash
go init example.com/myproject
```

(*厳密には `go mod init example.com/myproject`*)

---

### Q44 (選択: ディレクトリ構造で `cmd/`)

**問題**:
小規模～中規模の Go プロジェクトで「`cmd/` ディレクトリ」はどのような用途で使われることが多いでしょうか？

1. 依存ライブラリを手動でコピーし、すべてモノリポ化するためのフォルダ  
2. スクリプトや設定ファイル（Dockerfile やCI/CD用YAMLなど）を集約し、`main.go` は `apps/` ディレクトリに置く  
3. 実行可能ファイル（`main` パッケージ）を配置して複数のCLIツールやサブアプリケーションを管理しやすくする  
4. 画像やCSSファイル、ビルド成果物などを バージョン管理下で保管しておくための領域

**解答**: **(3)**

**解説**:
- 小～中規模の Go プロジェクトでは、よく「`cmd/ツール名/main.go`」のようにディレクトリを分けて複数の実行ファイルを管理します。これにより、1つのリポジトリ内でいくつもの CLI ツールやサブアプリをまとめつつ、`internal/` や `pkg/` の共通ロジックを使う形にできるため便利です。
- 例えば、以下のような構成が典型例です:
  ```
  myproject/
  ├── cmd/
  │   ├── toolA/
  │   │   └── main.go
  │   └── toolB/
  │       └── main.go
  ├── internal/
  │   └── ...
  ├── pkg/
  │   └── ...
  ├── go.mod
  └── ...
  ```
- **cmd/**: 実行可能ファイルごとにサブディレクトリを作り、`main.go` を配置  
- **internal/**: 外部からインポートさせたくない内部実装を置く  
- **pkg/**: 公開可能なパッケージや再利用ライブラリ  
  このようにして、プロジェクト単位で整理しやすくなるのが大きなメリットです。
**他の選択肢**:
- (1) 依存ライブラリを手動でコピーする方法は古い `vendor/` モードなどと混同しており、`cmd/` とは無関係です。  
- (2) スクリプトやDockerfileを `cmd/` に置く慣習は一般的ではありません。CI/CD 用ファイルは `build/`、`.github/workflows/`、または `scripts/` などに分けることが多いです。  
- (4) 画像・CSSなどのリソースやビルド成果物は通常、`static/` や `assets/`、`build/` ディレクトリなどに置き、`.gitignore` でバージョン管理外とするのが通例です。

---

### Q45 (選択: Docker マルチステージビルド)

**解答**: **(1)** 「1つ目のステージで `go build`、2つ目でバイナリだけをコピーし小さいイメージを作る」

**解説**:  
- これがよくあるDockerfileのマルチステージ構成。`go build` 用に大きなイメージを使い、その後小さいランタイムイメージにバイナリだけ移す。

---

### Q46 (短答: テストカバレッジ)

**解答例**:  
- 「テストで実際に実行されたコード行の割合（カバレッジ）を確認できる。」

**解説**:  
- `go test -cover` で関数や行がどのくらいテストされているか%表示してくれる。
- カバレッジとは「テストで実行されたコード行の割合」を示し、100%に近いほどテストが網羅的であることを示す。
- テストカバレッジを見ることで、どの部分がテストされていないかを把握し、テストの品質を向上させることができます。
- また、`go test -coverprofile=coverage.out` でカバレッジ情報をファイルに出力し、HTMLレポートを生成することも可能です。

---

### Q47 (選択: context.WithTimeout)
**問題**:
`context.WithTimeout(ctx, duration)` を使って一定時間後にキャンセルされるコンテキストを得た場合、タイムアウト後のゴルーチンはどうなるでしょうか？

1. タイムアウトが来た瞬間に、ランタイムがゴルーチンを強制終了させる  
2. ゴルーチンが `<-ctx.Done()` をチェックすれば、キャンセルを受け取って自主的に終了できる  
3. `context.WithTimeout` はデバッグ専用のAPIであり、実行時には何の影響もない  
4. Go は timeout/cancel という概念をサポートしていないため、実行結果は不定

**解答**: **(2)**

**解説**:
Go のコンテキスト機能は「強制終了」ではなく「キャンセルシグナルを送る」仕組みです。`WithTimeout` は指定時間後に `ctx.Done()` が close され、ゴルーチンはそれを受信すれば処理を中断するように **自主的** に動きます。以下が代表例です。
```go
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    go worker(ctx)

    // ここで5秒経過すると、自動でcancel()が呼ばれた状態と同様になり、
    // ctx.Done() がcloseされる
    <-ctx.Done() // メインが待ってみるケース
    fmt.Println("main done")
}

func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            // ここでキャンセル通知を受け取ったらゴルーチンを抜ける
            fmt.Println("worker: received ctx cancel signal")
            return
        default:
            // 通常処理
            time.Sleep(500 * time.Millisecond)
            fmt.Println("worker: doing some work")
        }
    }
}
```

**(2) が正解**:
- ゴルーチン内で `<-ctx.Done()` をチェックすることにより、キャンセルを“確認して”自主的に抜ける形をとります。  

**他の選択肢**:
- (1) タイムアウトが来ても「ランタイムがゴルーチンを強制終了する」わけではなく、「`ctx.Done()` が閉じられて呼び出し側が気づける」だけです。  
- (3) `context.WithTimeout` はデバッグ専用ではなく、実際のサーバや CLI プログラムでも一般的に使われるAPIです。  
- (4) Go にはキャンセル/タイムアウトの概念がしっかりあり、`context` パッケージが標準で提供しています。
---

### Q48 (選択: ジェネリクス多型パラメータ)

**解答**: **(2) `func combine[T, U](a T, b U) string { ... }`**

**解説**:  
- 複数の型パラメータがあるなら `[T, U]` のようにカンマ区切り。`(a T, b U)` で受け取る。

---

### Q49 (穴埋め: interface + generics)

**問題**の例:
```go
type Comparable interface {
    Compare(other any) int
}

func maxOf[T Comparable](x, y T) T {
    if x.Compare(y) > 0 {
        return x
    }
    return y
}
```
**解答**: 「`T` が `Comparable` を実装し、`Compare(other any) int` を提供する必要がある。具体的には `Compare` メソッドを定義する。」

- **解説**: たとえば  
  ```go
  type MyInt int
  func (m MyInt) Compare(o any) int {
      other, ok := o.(MyInt)
      if !ok { /* handle error */ }
      if m > other { return 1 }
      if m < other { return -1 }
      return 0
  }
  ```
  のように書くことで `maxOf` で比較できる。

---

### Q50 (選択: reflect)
**問題**: Go のリフレクション (`reflect`) を使うと何ができるでしょうか？

1. 実行中にソースコードを再コンパイルして、新たな関数を動的に生成する  
2. Go のバイナリ全体を逆アセンブルして、アセンブリ言語に変換して表示する  
3. ランタイム時に型の情報を取得し、動的にフィールド値やメソッドを読み書きできる  
4. Go の型に対して、例外のスローを自在に挿入して例外ハンドラをカスタマイズできる  

**解答**: **(3)**

**解説**:
Go のリフレクション (`reflect` パッケージ) は「実行時に型情報を取得し、フィールドやメソッドを動的に操作できる」仕組みです。具体的には、以下のような場面で使われます。
```go
import "reflect"

func PrintFields(v interface{}) {
    val := reflect.ValueOf(v)
    typ := val.Type()

    // struct の場合、フィールド数や名前・型を取得
    for i := 0; i < val.NumField(); i++ {
        fieldVal := val.Field(i)
        fieldName := typ.Field(i).Name
        fmt.Printf("Field: %s, Value: %v\n", fieldName, fieldVal)
    }
}
```

- 上記のように、**実行時**に “どんなフィールドを持つか” “値は何か” を調べたり、`fieldVal.Set(...)` のように書き換えたりすることが可能です。

**他の選択肢**:
- (1) 実行中にソースコードを再コンパイル…  
  Go のリフレクションはソースコードの再コンパイルや動的関数生成を行いません。あくまで型情報の取得・値の操作に留まります。
- (2) バイナリ全体を逆アセンブルして表示…  
  これは逆アセンブラの機能に近く、`reflect` には含まれていません。Go のリフレクションはアセンブリレベルではなく、高水準の型・値レベルで動きます。
- (4) 例外のスローを自在に挿入…  
  Go は基本的に `(result, error)` でエラー処理を行う言語で、**リフレクションで例外スローを挿入**する仕組みはありません。例外機構そのものが Java/C# のようには存在しないため、誤りです。
---

### **Q51**: Gin の基本ルート設定

**問題**:  
Go の Gin フレームワークで最もシンプルなWebサーバを起動し、`GET /ping` にアクセスすると `"pong"` を返す例のコードとして正しいものはどれでしょうか？  

1. 
```go
r := gin.Default()  
r.GET("/ping", func(c *gin.Context) {  
    c.JSON(200, gin.H{"message": "pong"})  
})  
r.Run()  
```

2. 
```go
r := gin.New()  
r.HttpGet("/ping", "pong")  
r.Listen(":8080")  
```

3. 
```go
http.HandleFunc("/ping", func(w http.ResponseWriter, r *http.Request) {  
    fmt.Fprintln(w, "pong")  
})  
http.ListenAndServe(":8080", nil)  
```

4. 
```go
gin.Start("/ping", "pong")  
```

**解答**: **(1)**

**解説**:  
Gin フレームワークで最もシンプルにWebサーバを起動し、「`GET /ping`」へのアクセスで `"pong"` を返すには、(1) のように以下の流れを踏みます。
- `gin.Default()` でデフォルトのルーターを作成 (ロギングやリカバリなどのミドルウェアが自動適用)  
- `r.GET("/ping", func(c *gin.Context) { ... })` でハンドラ登録し、`c.JSON(...)` によりレスポンスを返す  
- `r.Run()` によって `:8080` ポートで HTTP サーバを起動  

これが、Gin フレームワークで作る最小・典型的なサーバ実装です。

**他の選択肢**:  
- (2) `r.HttpGet("/ping", ...)` は Gin にはないメソッド名であり、`Listen(":8080")` も標準ではありません。
- (3) は Go 標準ライブラリ `net/http` を使った書き方であり、Gin フレームワークではありません。  
- (4) `gin.Start(...)` のようなAPI は存在しません。よく似た名前のユーザ定義ラッパを想起させるかもしれませんが、Gin の公式には用意されていません。

---

### **Q52**: Ginハンドラの引数

**問題 (再掲)**

```go
r.POST("/hello", func( (A) *gin.Context) {
    name := (A).Query("name")
    (A).String(200, "Hello %s", name)
})
```
**(A) に当てはまるのは何か？**

**解答**  
`(A) → c` （型は `*gin.Context`）

```go
r.POST("/hello", func(c *gin.Context) {
    name := c.Query("name")
    c.String(200, "Hello %s", name)
})
```

**詳しい解説**  
- Gin の各ハンドラは `func(c *gin.Context)` という形を取るのが基本。関数の引数名は自由だが、慣例的に `c` や `ctx` を使う。
- `c.Query("name")` は `GET /hello?name=Bob` のようなクエリパラメータを取得。「POSTでもクエリ文字列を使う」ことはあり得ますが、POSTボディで送る場合は `c.PostForm("key")` または `ShouldBindJSON(&obj)` を活用する。

**次の学習ステップ**:  
- 「クエリ文字列」「URLパラメータ」「フォームデータ」「JSONボディ」など、Gin で入力を受け取る方法を比較し、どの場合にどのメソッドを使えばいいか整理してみましょう。

---

### **Q53**: JSONバインド

**問題 (再掲)**  
Gin でクライアントが送ってきた JSON を構造体にバインドする代表的なメソッドはどれか？

1. `c.ShouldBindJSON(&obj)`
2. `c.QueryObject(&obj)`
3. `c.DecodeJSON(obj)`
4. `json.NewDecoder(c).Decode(obj)`

**解答**: **(1)**

**解説**  
- `ShouldBindJSON` (または `BindJSON`) は Gin 特有の関数で、HTTPボディを JSON として解析し、指定した構造体にマッピングしてくれます。エラー時は返り値で確認できます（ `err := c.ShouldBindJSON(&obj)` など）。
- (2) `c.QueryObject` は非実在、(3) `c.DecodeJSON` や (4) `json.NewDecoder(c).Decode(obj)` は標準ライブラリスタイルで書く場合の手法ですが、Gin なら簡単に `ShouldBindJSON` が使える。

**次の学習ステップ**:  
- 実際に `ShouldBindJSON` で受け取る構造体にタグ（ `json:"..."` ）を付けてみたり、バリデーションライブラリを使って必須項目のチェックを加えてみると、API作りが実践的になります。

---

### **Q54**: ステータスコードと JSON

**問題 (再掲)**  
「ステータスコード201 を返しつつ JSON ボディ」を1行で返すには？

**解答例**  
```go
c.JSON(201, gin.H{"id": newID})
```

**詳しい解説**  
- `c.JSON(statusCode, any)` はもっともシンプルな書き方で、任意のオブジェクト(`gin.H` や構造体)をJSON化し、指定したHTTPステータスで送信します。201 はリソース作成時の標準ステータスコード「Created」。
- 同様に `c.String(404, "Not Found")` のように文字列を送る方法などもある。

**次の学習ステップ**:  
- さまざまなステータスコード（200, 400, 401, 404, 500 など）と JSON を組み合わせる事例を試し、APIレスポンスを整えると実務的感覚がつかめます。

---

### **Q55**: URI パラメータ

**問題 (再掲)**  
`GET /users/:id` を定義しているルートから、`:id` を取得するにはどう書く？

1. `id := c.Query(":id")`  
2. `id := c.Param("id")`  
3. `id := c.FormValue("id")`  
4. `id, ok := c.Get("id")`

**解答**  
**(2) `id := c.Param("id")`**

**詳しい解説**  
- Gin の `Param` は「`/:param` と定義したURLパスの変数」を取り出すメソッド。例: `/users/:id` → `c.Param("id")` が文字列として返る。  
- (1) `c.Query("...")` はクエリパラメータ `?key=value` 用、(3) `c.FormValue` は net/http 標準のフォーム取得に近いもの（Ginでは通常 `c.PostForm` ）。(4) は `c.Get` でコンテキスト変数を取得するケース。

**次の学習ステップ**:  
- URIパラメータが整数IDなら文字列を `strconv.Atoi` で変換する必要があります。そこからバリデーションの入れ方などを検討すると、より安全なAPIを構築できます。

---

### **Q56**: ルートグルーピング

**問題 (再掲)**  
```go
r := gin.Default()
api := r.(B)("/api")
{
    api.GET("/ping", pingHandler)
    api.POST("/users", createUserHandler)
}
r.Run(":8080")
```
**(B)** に何を入れる？

**解答**  
`Group`

```go
api := r.Group("/api")
```

**詳しい解説**  
- `r.Group("/something")` で「ルートのプレフィックス + ミドルウェアの一括適用」ができる。`/api/ping`, `/api/users` などが定義しやすくなる。  
- サブグループも作るなど階層化できるため、大規模APIで便利。

**次の学習ステップ**:  
- グループにミドルウェアを付加する例（例: `api.Use(AuthMiddleware)`) を学ぶと、ルーティング設計がさらにわかりやすくなります。

---

### **Q57**: ミドルウェア

**問題 (再掲)**  
Gin でグローバルミドルウェアを有効にするには？

1. `r.Use(myMiddleware)`
2. `gin.SetMiddleware(myMiddleware)`
3. `http.HandleMiddleware(myMiddleware)`
4. `myMiddleware(r)`

**解答**  
**(1) `r.Use(myMiddleware)`**

**詳しい解説**  
- `r.Use(...)` を使うと、ルーター全体に対して前後処理やリカバリなどを挟むことができる。  
- 内部的には `r.engine.Handlers` に追加され、リクエストごとに順番に呼ばれる形。

**次の学習ステップ**:  
- ミドルウェアでロギング、認証チェック、CORS設定などを行う事例を学ぶと、本格的なAPI設計が行いやすくなります。

---

### **Q58**: DB と Gin ハンドラ

**問題 (再掲)**

```go
func getItemsHandler( (C) ) gin.HandlerFunc {
    return func(c *gin.Context) {
        // ...
    }
}
```

**解答**: `(C) => db *sql.DB`

```go
func getItemsHandler(db *sql.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        // db.Query(...) 
    }
}
```

**詳しい解説**  
- Go ではクロージャを使い、DBハンドルを引数で受け、Ginのハンドラ関数を返すやり方がよく用いられます。依存注入(DI)の簡易形とも言え、テストや拡張に有利。  
- Alternative: `c.MustGet("db").(*sql.DB)` でコンテキストに仕込む方法もあるが、関数引数で受けるほうが安全・明瞭。

**次の学習ステップ**:  
- 実際に DB クエリ (`SELECT`, `INSERT`) を書き、JSON で返すAPIを作ると、Go + Gin + DB のフローが体験できます。テストデータを仕込んでみるのも効果的です。

---

### **Q59**: クエリ文字列 vs JSONボディ

**問題 (再掲)**  
`GET /something?name=foo` から `name` パラメータを得るにはどの方法？

1. `c.PostForm("name")`
2. `c.Query("name")`
3. `c.ShouldBindQuery(name)`
4. `c.BindURI(&name)`

**解答**  
**(2) `c.Query("name")`**

**詳しい解説**  
- `c.Query("key")` は `/path?key=xxx` のクエリパラメータ取得用。  
- `c.PostForm("key")` は `POST` フォーム, `c.Param("id")` は `/:id`, `c.BindURI` はさらに構造体でURIパラメータをアンマッシュルするような仕組みに使う。

**次の学習ステップ**:  
- 実際に `GET /search?keyword=abc` のようなAPIを用意し、`c.Query("keyword")` を使って検索する例を作ると、クエリ取得を実践できます。

---

### **Q60**: 400 BadRequest

**問題 (再掲)**  
「400 BadRequest と JSON ボディ `{"error": "Invalid input"}` を返す一行」は？

**解答例**:
```go
c.JSON(400, gin.H{"error": "Invalid input"})
```

**詳しい解説**  
- `400` はクライアントのリクエストが不正という意味のステータスコード。Gin でエラーメッセージを JSON で返すパターンはよくあります。  
- これを細かく整形したい場合、構造体を返してキー名を指定したりも可能。ステータスコードについては[HTTP標準]などを参照しましょう。

**次の学習ステップ**:  
- エラー時に `c.AbortWithStatusJSON(400, ...)` と書き、後続処理を打ち切るフローなどを学ぶと、エラー処理設計がはかどります。  
- 実務ではエラーレスポンスを統一的に定義する（エラーコードや詳細メッセージなど）と大規模APIでも混乱が減ります。

---

# **まとめ**

**Q51〜Q60** では、**Go + Gin** の API 開発で重要な基本要素を一通りカバーしました。

1. **ルーティング**: `r.GET("/ping", ...)`, URIパラメータ (`:id` → `c.Param("id")`), クエリパラメータ (`c.Query("key")`), ルートグループ (`r.Group("/api")`), ミドルウェア (`r.Use`)  
2. **JSON 入出力**: `c.ShouldBindJSON(&obj)` で入力、 `c.JSON(200, gin.H{...})` で出力  
3. **DB 連携**: コンストラクタ的にハンドラへ `db` を渡す。`sql.DB` を使う例。  
4. **HTTP ステータスコード** と**エラーハンドリング**: `c.JSON(400, ...)`, `c.JSON(201, ...)` など  

これらを実際に試し、**小さなAPIサーバ**を作ると実務で使える感覚が得られます。**さらなるステップ**としては:

- **JWT 認証**: ミドルウェアでトークンを検証する  
- **Swagger/OpenAPI**: Gin で API ドキュメントを自動生成する  
- **ORM**: GORM などを使い、モデル定義とマイグレーション  
- **Docker/Kubernetes**: コンテナ上で Gin サーバを運用する  

など、いくつかの発展的トピックを学ぶと、**本格的なバックエンド開発**にスムーズに移行できます。以上の問題や解答を活用して、Go + Gin の基礎を着実に身につけてください。