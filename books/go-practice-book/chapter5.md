---
title: "第5章：Go の強み：並行処理（ゴルーチンとチャネル）"
free: true
---

# 第5章 Go の強み：並行処理（ゴルーチンとチャネル）

## 5.1 はじめに

### 5.1.1 並行処理の必要性と Go 言語の優位点

これまでの章では、Go 言語の基本文法やデータ構造、エラーハンドリング、テストなどを学んできました。しかし、Go 言語が数あるプログラミング言語の中でも「特に得意」としている領域の一つが、**並行処理**です。

#### なぜ並行処理が重要か

- **応答性の向上**  
  たとえば、ファイルのダウンロードやネットワーク通信などの「時間がかかる処理」が実行されている間も、ほかの機能を止めずに続けたいという要望は多くの場面で生じます。もし、すべての作業を順番に1つずつしか行えない「逐次処理」しかなければ、長時間の処理が終わるまで待たされることになり、アプリケーションの応答が悪くなってしまいます。

- **複数コアの効率活用**  
  現在のパソコンやサーバの CPU は、ほとんどが複数のコアを持っています。1つのコアだけを使うのではなく、**複数のコアを同時に使う**ようにすれば、大量の処理を短い時間で終わらせることが可能です。

- **Go 言語の強み**  
  Go 言語では、並行処理を実現するための仕組みとして**ゴルーチン (goroutine)** と**チャネル (channel)** を組み込みで提供しています。複雑なライブラリを自分で用意しなくても、**シンプルな構文**で並行処理を記述でき、また大量の並行タスクを少ないリソースで動かせるように設計されています。

---

## 5.2 並行処理と並列処理の違い

### 5.2.1 並行処理(Concurrency)

- **作業を切り替えながら“同時進行しているように見せる”**  
  同じ CPU コアであっても、高速にタスクを切り替えることで、多数の処理を一つの時間枠の中で進行させる手法を「並行処理」と呼びます。プログラムは見かけ上「同時に走っている」ように見えますが、実際には細かい時間単位でタスクを行ったり来たりしている状態です。  
- **Go 言語ランタイムでの並行**  
  Go 言語では、実行環境に関係なく「複数のゴルーチンが順番に走っている」状態を並行として記述できます。たとえ物理的にコアが1つしかなかったとしても、「ゴルーチン同士を切り替えながら」進むことで、複数の処理を進行しているように扱えるわけです。

### 5.2.2 並列処理(Parallelism)

- **実際に複数コアを使って“物理的に同時実行”**  
  コンピュータが複数コアを持っている場合、それぞれのコアで別々のゴルーチンを“本当に”同時に走らせることを「並列処理」といいます。結果として、同じ時間でより多くの仕事をこなせる可能性があります。  
- **Go 言語の自動並列化**  
  Go では、並行プログラミングの書き方をしておけば、実行環境のコア数に応じて自動的にゴルーチンを並列動作させることができます。要するに、「並行プログラム」を書いておくと、**コアが複数あるマシンで実行した場合、並列処理のメリットも得られる**という仕組みです。

---

## 5.3 ゴルーチンの基本

Go 言語が備える並行処理の中心的な要素が「ゴルーチン」です。ゴルーチンを使うと、**同じプログラムの中で複数の作業を同時に進める**ように書けます。

---

### 5.3.1 ゴルーチンとは何か

ゴルーチンを一言で説明するなら、**「プログラムの中で走る、もうひとつの“作業の流れ”」**です。同じプログラム内でありながら、まるで別の人が別の仕事をしているように、同時進行で関数を動かすことができます。

**たとえば**:
- 通常、`someFunction()` という関数を呼ぶと、その関数が全部終わるまで呼び出し元が待ち続けます。  
- ゴルーチンを使うと、「この関数を別の流れで動かしながら、呼び出し元もすぐ別のことを始めていい」というかたちにできます。

結果として、**複数の処理を一つのプログラムの中で同時並行に進める**ことができるのです。

---

### 5.3.2 どうやってゴルーチンを使うのか

Go 言語でゴルーチンを起動したい場合、**`go`** というキーワードを使います。「関数を呼ぶ」ときの文頭に `go` を付けるだけで、その関数を**別の流れ（ゴルーチン）**として動かしてくれるのがポイントです。

以下の例を見てみましょう。初めに、ゴルーチンを使わずに関数を呼ぶ場合と比較します。

#### ゴルーチンを使わない例

```go
package main

import (
    "fmt"
    "time"
)

func saySomething(msg string) {
    time.Sleep(2 * time.Second) // 2秒かかる作業
    fmt.Println(msg)
}

func main() {
    // 関数をそのまま呼ぶ
    saySomething("Hello")
    fmt.Println("Done")
}
```

この場合、`saySomething("Hello")` が終わるまで 2 秒待ち、終わった後に `fmt.Println("Done")` が実行されます。つまり、「`saySomething` → 完了 → `Done` 出力」という順番になります。

#### ゴルーチンを使う例

```go
package main

import (
    "fmt"
    "time"
)

func saySomething(msg string) {
    time.Sleep(2 * time.Second)
    fmt.Println(msg)
}

func main() {
    // 関数を別の流れ（ゴルーチン）で呼び出す
    go saySomething("Hello")

    // すぐに次の処理へ進む
    fmt.Println("Done?")

    // ここでプログラムが終わると「Hello」の出力が見れない可能性があるので少し待つ
    time.Sleep(3 * time.Second)
}
```

- **`go saySomething("Hello")`** と書くと、`saySomething("Hello")` は **別の流れ**として 2 秒かけて動き始めます。  
- `main` 関数はすぐに `fmt.Println("Done?")` を実行し、結果として画面に「Done?」が先に表示されるかもしれません。  
- その後、 2 秒経ったらゴルーチンが `Hello` と出力します。  
- ただし、もし `time.Sleep(3 * time.Second)` を入れなければ、メイン関数が先に終了してプログラム全体が終わり、ゴルーチンが動く前に終わってしまう可能性があるので注意が必要です。

---

### 5.3.3 ゴルーチンの注意点

1. **メイン関数が終わるとプログラム全体が終了する**  
   - たとえゴルーチンがまだ作業途中でも、メイン関数が `return` した時点でプログラムは終了してしまいます。  
   - そのため、ゴルーチンがすべて完了するまで待ちたい場合は、後で説明する `sync.WaitGroup` やチャネルなどの仕組みを使って、明示的に“待つ”記述をする必要があります。

2. **並行実行される関数の結果を即座に使いたいなら、同期の仕組みが必須**  
   - `go` キーワードだけだと、「関数の結果を後で受け取る」仕組みは含まれていません。受け取るためにはチャネルなどを使う必要があります。  
   - いくつかのゴルーチンを起動して、全員が終わるのを待ち合わせるときは、`sync.WaitGroup` が手軽です。

3. **ゴルーチンの数が増えすぎるとリソースを消費する**  
   - Go 言語のゴルーチンは比較的軽量ですが、数十万～数百万単位で無制限に立ち上げようとすると、メモリ不足やスケジューリングオーバーヘッドが発生する可能性があります。必要に応じて“プール”を作るなど設計上の工夫も大切です。

### 5.3.4 `sync.WaitGroup` を使った同期

#### 5.3.4.1 何をするか

- **WaitGroup** は「あと何個のゴルーチンが作業中か」をカウントし、すべてが終了するのを待機する仕組みです。  
- **Add()**: カウンタを増やし、「ゴルーチンを n 個起動するよ」と宣言する。  
- **Done()**: ゴルーチンが終わる際に呼び出してカウンタを1つ減らす。  
- **Wait()**: カウンタが0になる（全ゴルーチンが終わる）までブロックする。

#### 5.3.4.2 簡単な例

```go
var wg sync.WaitGroup

wg.Add(1)
go func() {
    defer wg.Done()
    // 何らかの処理
}()

// 別のゴルーチン
wg.Add(1)
go func() {
    defer wg.Done()
    // 別の処理
}()

wg.Wait() // 2つのゴルーチンがDone()するまで待機
```

- **これにより、メイン関数が先に終わってしまうことを防ぎ、すべてのゴルーチンの完了を確認**できます。  
- プログラム初心者の方には、「何人かが別々の作業をしているなら、全員が終了報告をしてから帰ろう」と決めているイメージに近いと考えてください。
---

### 5.3.5 まとめ：ゴルーチンの基本イメージ

- **「`go` キーワード」**を付けることで、関数の呼び出しを独立した流れとして動かせる。  
- ただ呼ぶだけだと結果を待たないので、メイン関数がすぐ終了するとゴルーチンも道半ばで打ち切られる恐れがある。  
- 複数のゴルーチンを安全かつ効率的に扱うには、**同期の仕組みやチャネル**を併用するのが Go 言語のパターン。

---

## 5.4 チャネル (channels) の基本

ゴルーチンを起動して並行実行できても、「それぞれがどうやって結果を集約するか」「途中の状態をやり取りするか」という課題が残ります。Go 言語はこれを解決するために、**チャネル (channel)** という仕組みを備えています。

前章で学んだゴルーチンによって、私たちはプログラムの中で「複数の処理を同時に進める」書き方ができるようになりました。しかし、並行に動くゴルーチン同士が「まったく関係なく動くだけ」では、実用的なプログラムになりにくいケースがたくさんあります。

- **たとえば**、ゴルーチンAが時間のかかる作業をして、その結果をゴルーチンBに渡したい場合、**どのようにしてAの計算結果をBへ伝えるか**を決めておかないといけません。  
- もし同じ変数を共有して書き込もうとすると、タイミングによってはデータが上書きされたり、競合が起きる可能性があります。これは「並行プログラムのバグ」として有名な問題で、デバッグが非常に難しいことで知られています。

Go 言語が推奨する解決策は、「同じ変数を共有してバタバタやるのではなく、**“メッセージを渡す” 形でゴルーチン同士をつなぐ**」というやり方です。ここでいう「メッセージ」は、送る側が「はい、これをどうぞ」と値を渡し、受け取る側が「じゃあ、それを受け取ります」と待ち構える、というイメージです。

**チャネル (channel)** は、その「メッセージ交換」を簡潔かつ安全に行うための仕組みです。

1. **ゴルーチンAが「ある値」をチャネルに送信**すると、ゴルーチンBが「その値」を受け取れる。  
2. そのときの送受信が、**並行プログラムのタイミングを決める“同期点”**としても機能するため、「いつ受け取ったか」「受け取る前に何が終わっているか」をゴルーチン同士が明確に把握できます。  
3. 共有変数を直接上書きし合うのではなく、**チャネルを介してデータをやり取りする**ため、データ競合を起こしにくいメリットも得られます。

こうした特徴により、Go で並行処理を書く際は**「できるだけチャネルを使うことで、複数のゴルーチンのやり取りを分かりやすく管理しよう」**というスタイルが推奨されています。  

以下では、**チャネルの作り方**や**実際の送受信の書き方**、さらに**バッファ付きかバッファなしチャネル**かといった選択肢について詳しく見ていきます。

### 5.4.1 チャネルの作り方と送受信
Go 言語では、チャネルを扱う際に **`chan`** という単語を使います。これは、Go の型システムにおける**チャネル型**を宣言するときに用いるキーワード（型キーワード）です。たとえば `chan int` は「int 型の値を送受信するためのチャネル型」という意味になります。  
- 例: `var c chan int` と書くと、「int 型を送受信できるチャネル型の変数 c を宣言する」ことになります。

#### 5.4.1.1 `make(chan 型[, バッファ])`
チャネルを実際に使える状態に初期化するためには、**`make` 関数**を呼ぶ必要があります。Go 言語においては、**“内部に仕組みを持つ型（スライス・マップ・チャネルなど）”**を作るときは `make` を使うというルールになっています。

```go
c := make(chan int)         // バッファなし
bc := make(chan string, 10) // バッファ付き(容量10)
```

- **バッファなしチャネル**: 送信と受信が同時に起こらない限り、どちらかがブロックされる。通信と同期を同時に実現できる。  
- **バッファ付きチャネル**: 一定サイズのバッファを持つため、その容量内であれば送信がすぐに完了し、受信が遅れても大丈夫。ただし、バッファがいっぱいになると送信がブロックされることは同じ。

#### 5.4.1.2 送信と受信の文法

```go
c <- 100   // 送信( c に 100 を渡す)
x := <- c  // 受信( c から値を取り出して x に格納)
```

- **“<-”**演算子は矢印の向きを見れば「右から左へ値が渡される」イメージを持てます。  
- 受信側がいなければ送信はブロック、送信側がいなければ受信はブロック(バッファなしの場合)。バッファ付きの場合はバッファに空きがあれば送信即完了、空きがないと送信がブロック、といった動きです。

#### 5.4.1.3 例：シンプルなゴルーチン間通信

```go
func main() {
    c := make(chan int)
    go func() {
        time.Sleep(2 * time.Second)
        c <- 42 // 2秒後に42を送信
    }()

    fmt.Println("Waiting for result...")
    x := <-c // 受信が来るまでここでブロック
    fmt.Println("Got result:", x)
}
```

- **流れ**: 裏で `time.Sleep(2 * time.Second)` が終わると、`c <- 42` が実行され、メイン側の `x := <-c` がブロック解除される。  
- **メリット**: Sleepで疑似的に時間のかかる作業を行っているが、この作業完了までメインは“他の処理もできる”。ただし、ここではすぐに受信行で止まってしまう例なので、WaitGroupなどを使いながらうまく組み合わせる場合が多いです。

---

## 5.5 並行ダウンロード例

それでは、ゴルーチンとチャネルを使った少し実用的なサンプルとして、**複数のURLを同時にダウンロードして結果を受け取る**流れを見てみましょう。実際のダウンロード処理をすべて書くと長くなるので、簡単に疑似処理で紹介します。

### 5.5.1 どんな動きをするか

1. URLリストが `[A, B, C, ...]` とあったとき、各URLごとにゴルーチンを1つ起動し、ダウンロード(あるいは疑似処理)をスタート。  
2. 各ゴルーチンは、完了したらチャネルに「このURLがダウンロード成功したよ」というメッセージを送る。  
3. メイン関数はURLの数だけチャネルを受信し、結果を表示する。結果として、ダウンロードが並行に行われ、全URL分の結果が出るまで待機できる。

### 5.5.2 コード例（簡略版）

```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

func download(url string, results chan<- string) {
    // 疑似的に 1~3秒ランダムで"ダウンロード"
    sleep := time.Duration(rand.Intn(3)+1) * time.Second
    time.Sleep(sleep)
    results <- fmt.Sprintf("Downloaded %s (took %v)", url, sleep)
}

func main() {
    rand.Seed(time.Now().UnixNano())

    urls := []string{
        "http://example.com/a",
        "http://example.com/b",
        "http://example.com/c",
    }

    results := make(chan string)

    for _, url := range urls {
        go download(url, results)
    }

    // URL の数だけ結果を待って表示
    for i := 0; i < len(urls); i++ {
        res := <-results
        fmt.Println(res)
    }

    fmt.Println("All downloads completed.")
}
```

#### 解説

- **流れ**: `download` 関数が、ランダムな時間 `Sleep` の後に、`results <- ...` でメッセージを送信。メインは `for i := 0; i < len(urls); i++` で同じ回数だけ受信し、表示する。  
- **利点**: 全URLが一斉に並行ダウンロードされるため、もしネット回線やサーバ側が許すなら、**トータル時間は逐次ダウンロードより短く**なることが期待できる。  
- **注意**: 実際のネットワーク操作ではエラーがあり得るため、エラーをチャネルに送るか別の仕組みで管理する設計が求められます。

---

## 5.6 課題：ゴルーチン + チャネルの活用

### 5.6.1 課題1：複数タスクの並行実行

- **内容**: 複数のタスク（例えば 1～5 の数字など）を同時に処理し、それぞれの完了時にメインへ報告するプログラムを作ってください。疑似処理として `time.Sleep` を使って「タスクiは i 秒かかる」としてもよいでしょう。  
- **狙い**: ゴルーチンでタスクを並列に開始し、完了時にチャネルへ結果を送る構造を体感する。  
- **必要な要素**: 
  1. `make(chan string)` などのチャネル  
  2. `go func() {  ...  }()` で各タスクを走らせる  
  3. メイン関数がタスク数回だけ受信して結果をまとめる。  
- **発展**: バッファ付きチャネルにして、より柔軟に送信受信を行う、エラーも含めて送信するなどの拡張。

### 5.6.2 課題2：バグ修正（デッドロックやチャネル未クローズ）

- **内容**: 付録やサンプルリポジトリにある「buggy_concurrent.go」ファイルがあり、複数URLを並行ダウンロードして結果をまとめるはずなのに、途中でプログラムが止まったり、完了しなかったりするバグがある。これを修正する。  
- **狙い**: 実務でも多い「デッドロック」や「チャネルが閉じていないせいで受信側が無限に待つ」などの並行バグを知る。  
- **ポイント**: 
  1. チャネルを `close()` すべきかどうか  
  2. `WaitGroup` や `select { ... }` を使うべきか  
  3. バッファサイズが不適切で送信側がブロックしている可能性はないか  
  4. メイン関数が先に終わらないように同期が取れているか

---

## 5.7 さらに深める並行処理のトピック

ここでは、初級～中級レベルの学習者が「もっとGoの並行処理を使いこなしたい」という方向けに、少し進んだ話題を挙げておきます。興味や余裕があれば試してみてください。

### 5.7.1 `select`文による複数チャネルの同時待ち

- **何をするか**: 複数のチャネルを監視し、先にどれかのチャネルからデータが来たらその処理を行う。  
- **例**: `select` で「データチャネル」と「タイムアウトチャネル」を同時に待ち、「データが来たら受信、来ないまま数秒経過したらタイムアウト」といった処理を実装できる。  
- **メリット**: 1つのブロックで複数のイベントを待てるため、柔軟な並行パターンを簡潔に書ける。

```go
select {
case val := <-dataCh:
    fmt.Println("Received data:", val)
case <-time.After(2 * time.Second):
    fmt.Println("Timeout!")
}
```

### 5.7.2 コンテキスト (contextパッケージ) でのキャンセル制御

- **何をするか**: `context.WithCancel` や `context.WithTimeout` を使い、一連のゴルーチンに「そろそろ終わってください」という合図を送る。ネットワークサーバや長時間計算でよく使われる。  
- **なぜ必要か**: ゴルーチンがいつまでも動き続けると、メモリリークや無駄なCPU消費の原因に。キャンセル合図を送って停止させる仕組みを整えれば、資源管理が容易に。  
- **どうやって使うか**: 各ゴルーチンが `select { case <-ctx.Done(): return }` のようにキャンセル通知を受け取り、終了するパターンが代表的。

### 5.7.3 共有変数の保護：Mutex 等

- **何をするか**: `sync.Mutex` や `sync.RWMutex` を使って、並行実行中に同じ変数を上書きしてしまうのを防ぐ。  
- **なぜ使うか**: チャネル方式で書くのが理想とされるが、どうしても共有メモリを直接アクセスするシーンがある場合に必要。  
- **注意点**: Mutex はロックとアンロックのペアを正しく管理しないとデッドロックが生じたり、逆に競合が生じる。Go ではなるべくチャネルを使い、メモリ共有を必要最小限に抑える方針が推奨される。

---

## 5.8 まとめ

### 5.8.1 本章の要点

1. **並行処理 vs 並列処理**  
   - 1つのCPUコアでタスクを切り替えながら実行するのが並行処理、複数コアで物理的に同時実行するのが並列処理。Go言語は“並行プログラミング”が書きやすく、環境によって並列化も容易に達成できる。

2. **ゴルーチン**  
   - `go` キーワードで関数を呼び出すと、その関数が独立したゴルーチンとして並行に動く。スレッドより軽量で、大量のゴルーチンを扱える。メイン関数が終了するとゴルーチンも打ち切られるため、同期手段(WaitGroupなど)を活用する。

3. **チャネル (channel)**  
   - ゴルーチン間のデータ交換と同期を同時に実現する仕組み。`c := make(chan int)`で作り、`c <- value` で送信、 `val := <-c` で受信。バッファなしとバッファ付きがあり、使い分けが大切。

4. **並行ダウンロード例**  
   - 複数のURLを同時に処理し、完了報告をチャネルで受け取る流れをコードにしやすいのがGo言語の強み。長時間I/Oを並行化することで、ユーザの待ち時間短縮や効率化が図れる。

### 5.8.2 章末課題のおさらい

- **ゴルーチン + チャネルでタスクを並行実行**  
  - 複数のタスクを同時にスタートし、チャネルで結果や完了を報告するプログラムを自作。  
- **バグ入り並行コードの修正**  
  - デッドロックを引き起こす誤ったチャネルの閉じ方やバッファ設定を直し、安全に並行処理を完了させる。

### 5.8.3 次のステップ

- **第6章**: CLI版アプリ構築  
  ここで身につけた並行処理のスキルを活かし、小規模なアプリ内で複数作業を同時に行う仕掛けを実装できる。リマインド機能やバックグラウンドタスクなどを盛り込み、より現実的なプログラムを目指せる。

- **第7章**: Webアプリ（HTTPサーバ）  
  Go言語でWebサーバを立ち上げると、リクエストを並行にさばく仕組みがデフォルトで備わっている。チャネルを組み合わせると、Webサーバ内で複数の処理を同時進行させ、結果をまとめるアーキテクチャを容易に書ける。

- **さらなる並行プログラミング手法**  
  `select`文で複数チャネルを同時に待つ、`context`でキャンセル制御する、`sync.Mutex`で共有データを保護する、といった上級技を学ぶことで、大規模・高負荷のアプリケーションにも耐えうる並行設計が可能になる。

---

## エピローグ

**本章では、Go 言語が強力な機能として提供する“並行処理（ゴルーチン）”と“チャネル”を中心に解説しました。** 並行・並列の基本概念から始まり、WaitGroup による同期やチャネルでのデータ交換といった具体的な使い方まで、一通りの流れを学んできました。

- **並行処理は難しそう？**  
  確かに、複数の処理が同時に動くとなると頭がこんがらがるイメージがあるかもしれません。しかし、Go 言語は`go` キーワードとチャネルで、それを最小限の複雑さで表現できます。初めは「別の関数を並行に走らせる → 結果をチャネルで受け取る」といったシンプルな例から練習し、段階的に理解を深めてください。

- **デッドロックやレースコンディション**  
  並行プログラムが増えると、送信と受信が合わずに永久に待ち状態になるデッドロックや、共有変数を同時書き込みしてバグを引き起こすレースコンディションなど、並行特有の不具合も起きやすくなります。本章の章末課題でこうしたバグの修正を体験し、実務での落とし穴に備えましょう。

- **次章やその先**  
  第6章では、この並行処理技術を CLI アプリに落とし込み、具体的なユースケースを体感します。さらに第7章では Web サーバへ応用し、第8章では Lint と CI/CD を交えて品質管理まで踏み込みます。そこでもゴルーチンやチャネルは多用され、Go 言語ならではのシンプルさを味わえるはずです。

以上で**第5章**「Go の強み：並行処理 (ゴルーチンとチャネル)」を終わります。**ぜひ演習とバグ修正を通じて、並行プログラミングの手応え**を得てください。**Go 言語なら、初心者でも比較的安全かつ容易に並行処理をマスターできる**はずです。次の章へ進む前に、いくつか小さな並行プログラムを手書きしながら試してみることをおすすめします。

