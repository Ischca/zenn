---
title: "第6章：CLI版タスク管理アプリを作る"
free: true
---

# 第6章：CLI版タスク管理アプリを作る ～仕様策定から開発フローを学ぶ～

---

## 6.1 はじめに

### 6.1.1 本章の位置づけ

これまでの章では、Go 言語の基本文法やデータ構造、エラーハンドリング、テストなど、言語の根幹を一通り学習してきました。ここまでの知識は断片的なサンプルコードで確認してきましたが、本章ではそれらを**総合的に組み合わせ**、**一つのアプリケーション**を完成させることを目標とします。

具体的には、**CLI（コマンドライン）版のタスク管理アプリ**を題材とし、**仕様策定 → 実装 → テスト → 改良**という実践的な開発フローを段階的に体験していただきます。GUIやWebの概念に踏み込まず、**あえてCLI版**を選ぶことで、**Go言語のロジック習得**と**仕様設計の思考**に集中できます。

### 6.1.2 なにを学ぶのか

- **小規模アプリの仕様策定**：  
  どのような機能が必要か、どんな操作をユーザに提供するか、エラー時の挙動はどうあるべきか等を明文化します。

- **実装フローとテスト**：  
  仕様を実装したら、テストコードを用いて動作確認し、バグがないかチェックします。コマンドラインからの動作確認も平行して行うことで、ユーザ目線の不具合にも気付きやすくなります。

- **改良・拡張**：  
  削除機能を付け足したり、ファイル保存を取り入れたり、並行処理で定期リマインドを行ったりすることで、より実務的な仕様に近づける過程を体験します。  

### 6.1.3 なぜこの手法を学ぶのか

1. **開発フローを身につける**  
   ただ言語文法を覚えるだけでは、実務で通用するプロダクトを作るのは難しいです。本章では、一連の流れ（仕様 → 実装 → テスト → 改良）を何度も意識し、**「なぜその仕様にするのか」「なぜその実装を選ぶのか」**を自問自答する力を養います。

2. **CLI版が最適な学習ステップ**  
   GUIやWebのUI要素を設計する手間を省き、**Go 言語の本質（ロジック・テスト・エラーハンドリングなど）**に集中できる点が大きなメリットです。後続の第7章でWeb版に移行する際にも、CLI版で作ったビジネスロジックをほぼそのまま再利用可能になります。

3. **実務にも通じる基礎を確立**  
   仕様策定やテストの概念は、小規模アプリでも大規模システムでも本質は同じです。本章を通じて**「小さな範囲でも仕様をしっかり定義し、テストで担保する」**開発文化を体験することが、将来大きな規模のプロダクトに挑む際の基盤となります。

### 6.1.4 どうやって進めるか

- **最小限の機能を決める**：  
  まずはタスクの「追加 (add)」「一覧表示 (list)」「完了処理 (done)」という 3 つだけに絞り、短期で動くものを作ります。

- **設計と分割**：  
  CLI部分（コマンド解析）とタスク操作ロジック（データ構造・関数）を別ファイルに分け、**責務分離**を意識します。

- **テストコードの整備**：  
  タスク操作ロジックは`_test.go`ファイルで仕様どおり動くか確認し、**バグ検知と仕様維持**を両立します。

- **段階的に改良**：  
  削除機能やファイル保存など必要な機能を追加し、そのたびに仕様を明確化、テストを追加、動作確認する「スモールステップの改良」を体験します。

---

## 6.2 仕様策定：なにを作るのか／なぜそう決めるのか

### 6.2.1 CLI版タスク管理アプリの概要

#### 6.2.1.1 どんな機能を提供するか

- **add <タイトル>**  
  例：`go run main.go add "買い物に行く"`  
  新しいタスクを作成し、IDを付与して内部リストに登録。

- **list**  
  例：`go run main.go list`  
  登録されたタスクをすべて一覧表示し、完了済みか未完了かを視覚的に区別。もしタスクが0件なら「No tasks found.」と表示。

- **done <ID>**  
  例：`go run main.go done 2`  
  指定IDのタスクを完了済み（Done=true）に変更。IDが存在しない場合はエラーを返す。

#### 6.2.1.2 なぜこの範囲にするのか

1. **最小限でCRUDの流れをカバー**  
   「追加（Create）」「閲覧（Read）」「更新（Update：完了にする）」が含まれ、学習のコアとなる。削除（Delete）はオプションとして後で追加してもよい。

2. **学習スコープを短期集中に絞る**  
   複雑な仕様（優先度や期限、ユーザ認証など）を最初から盛り込むと混乱を招き、短期間では仕上げにくい。**スモールスタート**で完成体験を得ることが大切。

3. **拡張しやすい**  
   3コマンドだけでもタスク管理の基本は成立し、必要に応じて「削除」「並行リマインド」「ファイル保存」などを段階的に付け足せる。**拡張性と初心者の理解度向上**を両立できる。

#### 6.2.1.3 どのように実装方針を立てるか

- **CLIを `os.Args` で解析**:  
  サブコマンド名 (`add/list/done`) を取得し、該当ロジックを呼び出す。  
- **タスクデータの保持**:  
  スライス `[]Task` かマップ `map[int]Task` のいずれか。ここでは「線形探索でも構造が単純なスライス方式」を選ぶ。  
- **エラー処理**:  
  タイトルが空文字ならエラーを返す。`done`でIDが見つからなければエラーを返す。CLI上でエラーメッセージを表示し、処理を中断。  
- **テスト**:  
  仕様策定段階で「空文字タイトルはエラー」「ID不在はエラー」と決めたので、テストコードで正常系・異常系を両方チェックする。

---

## 6.3 設計：ファイル分割とデータ構造

### 6.3.1 ファイル構成

#### 6.3.1.1 何を分割するか

- **main.go**: コマンドライン解析部分  
- **task.go**: タスク操作ロジック（データ構造と各関数）  
- **task_test.go**: テストコード  
- **(オプション) storage.go**: ファイル保存実装

#### 6.3.1.2 なぜ分割するのか

1. **責務分離の明確化**  
   CLIの入出力処理は `main.go`、ビジネスロジック（タスク追加・一覧・完了）は `task.go` に集約することで、コードが整理され、変更に強くなる。

2. **テスト容易性**  
   `task.go` の関数をそのままテストできるため、CLI部分の煩雑なI/Oの影響を切り離して検証できる。

3. **拡張に備える**  
   将来的にWeb版（第7章）へ移行する際、`main.go` を変更してHTTPハンドラにするだけで、`task.go` のロジックは使い回せる。

#### 6.3.1.3 どのように分割するか

- **main.go**: `func main()` 内で `os.Args` の要素数チェック → cmd取得 → `switch cmd` → `case "add": AddTask(...)` など。  
- **task.go**: グローバルな `var tasks []Task`、`var lastID int`、そして `AddTask(title)`, `ListTasks()`, `DoneTask(id)` の3関数を定義。  
- **task_test.go**: `go test` で実行されるテストを書き、`AddTask`, `DoneTask` などが仕様通り動くか検証。  
- **storage.go**(任意): `SaveTasks`, `LoadTasks` といったファイルI/Oをまとめる。最初は実装しなくても良い。

---

### 6.3.2 データ構造

```go
type Task struct {
    ID    int
    Title string
    Done  bool
}
```

#### 6.3.2.1 何を持たせるか

- **ID**: ユニークな整数。タスクを区別するために必要。  
- **Title**: タスクの内容。空文字は本アプリの仕様上エラーとする。  
- **Done**: 完了フラグ（true/false）。

#### 6.3.2.2 なぜこの設計か

1. **シンプルで分かりやすい**  
   スモールスタートするうえで最小限のフィールド。期限や優先度は後から拡張可能。

2. **整数IDが管理しやすい**  
   CLIで `done 2` のように指定しやすく、文字列より初心者には理解が容易。大規模化すればUUIDを検討しても良いが、ここでは短期学習に集中する。

3. **Doneフラグで完了/未完了を表現**  
   bool一つで状態を示せるため、**list**コマンドで表示を変えやすい。別のステータス（in-progress, canceled等）を追加したいなら、enum的な扱いに発展可能。

#### 6.3.2.3 どのように管理するか

- **スライス `var tasks []Task`**  
  - `AddTask` が呼ばれれば、新規のTaskを作成して `append(tasks, newTask)`  
  - `DoneTask(id)` で線形探索し、該当IDを見つけて `Done=true`  
  - 削除を入れるなら `delTask(id)` で線形探索し、削除後に `tasks = append(tasks[:i], tasks[i+1:]...)`

- **ID自動発番**  
  - `var lastID int` をグローバルに持ち、`AddTask` で `lastID++` → その値をIDとしてTaskにセット。  
  - ID周りで複雑にならないようにするため、再利用などは当面考えない。

---

## 6.4 実装：CLI解析とタスク操作関数

### 6.4.1 `main.go` ～ CLI解析の全体像

以下はコード例（簡略化）。**行ごとに「なにをしているか」や「なぜそう書いているか」を付記**しつつ解説します。

```go
package main

import (
    "fmt"
    "os"
    "strconv"
)

// main: CLIの入口。os.Argsを解析し、対応するタスク操作ロジックを呼び出す。
func main() {
    // 1) 引数数をチェック (コマンド名が無いと実行できないため)
    if len(os.Args) < 2 {
        fmt.Println("Usage: go run main.go <command> [arguments]")
        return
    }

    cmd := os.Args[1] // 2) コマンドを取得 ("add", "list", "done" 等)

    switch cmd {
    case "add":
        // "add"の場合、タイトル(タスク名)が後ろに続くはず
        if len(os.Args) < 3 {
            fmt.Println("Error: Task title is required.")
            return
        }
        title := os.Args[2]
        // タスク追加関数を呼ぶ
        newTask, err := AddTask(title)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Task added: ID=%d, Title=%q, Done=%v\n", newTask.ID, newTask.Title, newTask.Done)

    case "list":
        // 一覧表示。task.goに定義したListTasks()を単純に呼ぶ
        ListTasks()

    case "done":
        // "done <ID>"の形を想定。IDを数値に変換
        if len(os.Args) < 3 {
            fmt.Println("Error: Task ID is required.")
            return
        }
        id, err := strconv.Atoi(os.Args[2])
        if err != nil {
            fmt.Println("Invalid ID:", os.Args[2])
            return
        }
        // done処理
        err = DoneTask(id)
        if err != nil {
            fmt.Println("Error:", err)
            return
        }
        fmt.Printf("Task #%d marked as done.\n", id)

    default:
        // 想定外のコマンド
        fmt.Println("Unknown command:", cmd)
    }
}
```

- `main` 関数は、「ユーザの入力を取り込み → コマンド解析 → それに対応するビジネスロジックを呼び出す」責務を担います。  
- CLI版であれば、UI部分はこの程度のswitch文で十分。学習者が複雑なフラグパーサーに悩む必要がない。  
- `os.Args[1]` がコマンド名。`os.Args[2]` やそれ以降の引数を必要に応じて取り出し、ビジネスロジックへ渡します。

---

### 6.4.2 `task.go` ～ ビジネスロジック

```go
package main

import (
    "errors"
    "fmt"
)

var tasks []Task
var lastID int

type Task struct {
    ID    int
    Title string
    Done  bool
}

// AddTask: 新しいタスクを追加。タイトル空ならエラー。
func AddTask(title string) (Task, error) {
    // タイトルが空ではユーザが何をやるか分からないため、仕様としてエラーとする
    if title == "" {
        return Task{}, errors.New("task title cannot be empty")
    }

    lastID++ // 連番管理
    t := Task{
        ID:    lastID,
        Title: title,
        Done:  false,
    }
    // スライスに追加 (メモリ上に保持)
    tasks = append(tasks, t)
    return t, nil
}

// ListTasks: 現在のタスクリストを表示
func ListTasks() {
    // タスクが0件ならメッセージを出す仕様にする
    if len(tasks) == 0 {
        fmt.Println("No tasks found.")
        return
    }
    // ループで完了/未完了を区別
    for _, task := range tasks {
        status := "[未完了]"
        if task.Done {
            status = "[完了]"
        }
        fmt.Printf("%s %d) %s\n", status, task.ID, task.Title)
    }
}

// DoneTask: 指定IDのタスクを完了に設定。無ければエラー。
func DoneTask(id int) error {
    for i := range tasks {
        if tasks[i].ID == id {
            tasks[i].Done = true
            return nil
        }
    }
    // IDが見つからない場合
    return fmt.Errorf("task with ID=%d not found", id)
}
```

- `AddTask` はタイトルが空ならエラー、そうでなければ新規Taskを生成。`ListTasks` は画面出力、`DoneTask` はID検索で `Done=true`。  
- 
  - `AddTask` の空タイトルエラー → 仕様で「意味のあるタイトルが必須」と決まっている  
  - `ListTasks` → CLI版では引数を受け取らず、一気に全タスクを表示するだけがシンプル  
  - `DoneTask` → IDがない場合、隠れて処理を飛ばすのではなくエラーを返してユーザに認知させる  
- 
  - `AddTask` で `lastID++` して Task を作り、`append(tasks, t)`  
  - `ListTasks` は `range tasks` して完了フラグで表示を変える  
  - `DoneTask` は線形探索し、該当インデックスの Done をtrueにする

---

## 6.5 テスト：仕様通り動いているかを担保

### 6.5.1 なぜテストを書くか

1. **仕様の継続的検証**  
   バグ修正や機能追加を行っても、既存の仕様を壊していないかチェックするため。特に「空タイトルでエラーを返す」などは曖昧になりがちですが、テストがあると確実に再検証できます。

2. **開発の効率向上**  
   CLIでいちいち操作するより、テストを走らせたほうが高速に多くのケースを試せます。**短期学習**でも開発サイクルを高速化でき、誤実装を早期に発見しやすくなります。

3. **コード品質の向上**  
   テストを書く習慣が根付くことで、**エラー処理やデータ境界条件**を意識せざるを得なくなり、結果として堅牢なアプリケーションに近づきます。

### 6.5.2 どのようにテストするか

Go 言語の標準テストフレームワークを使い、`task_test.go` で以下のように書きます。

```go
package main

import (
    "testing"
)

// TestAddTask: AddTaskの正常・異常ケースをテスト
func TestAddTask(t *testing.T) {
    // テスト独立性を保つため、毎回初期化
    tasks = []Task{}
    lastID = 0

    // 1) 正常ケース
    task, err := AddTask("Buy milk")
    if err != nil {
        t.Errorf("expected no error, got %v", err)
    }
    if task.ID != 1 {
        t.Errorf("expected ID=1, got %d", task.ID)
    }
    if task.Title != "Buy milk" {
        t.Errorf("expected title to be 'Buy milk', got %q", task.Title)
    }

    // 2) 異常ケース: 空タイトル
    _, err = AddTask("")
    if err == nil {
        t.Errorf("expected error for empty title, got nil")
    }
}

// TestDoneTask: DoneTaskの挙動を検証
func TestDoneTask(t *testing.T) {
    tasks = []Task{}
    lastID = 0

    AddTask("Task A")
    AddTask("Task B")

    // ID=2を完了にするとDoneがtrueになる想定
    err := DoneTask(2)
    if err != nil {
        t.Errorf("DoneTask(2) returned err: %v", err)
    }
    if tasks[1].Done != true {
        t.Errorf("Task #2 was not set to Done=true")
    }

    // 存在しないID=99でエラーを期待
    err = DoneTask(99)
    if err == nil {
        t.Errorf("expected error for non-existing ID, got nil")
    }
}
```

- AddTaskとDoneTaskを、**正常系**と**異常系**の両面でテストしています。  
- 仕様で「空タイトルはエラー」「存在しないIDはエラー」と決まっているため、その挙動が崩れないか継続的にチェックする。  
- 毎回 `tasks = []Task{}; lastID=0` で初期化し、テストが相互に干渉しないようにする。

#### テスト実行

```bash
go test -v
```
**もし成功すれば**「PASS」、失敗すればエラーの詳細が表示されます。  
- 自動化することで、仕様と実装の乖離を早期発見。何度もテストを走らせ、安心してリファクタリング可能。

---

## 6.6 実際の動作確認と改良

### 6.6.1 CLI操作の動作例

```bash
$ go run main.go add "Clean the room"
Task added: ID=1, Title="Clean the room", Done=false

$ go run main.go add "Write blog post"
Task added: ID=2, Title="Write blog post", Done=false

$ go run main.go list
[未完了] 1) Clean the room
[未完了] 2) Write blog post

$ go run main.go done 1
Task #1 marked as done.

$ go run main.go list
[完了] 1) Clean the room
[未完了] 2) Write blog post
```

- コマンドを連続入力し、想定どおりにタスクが追加・完了されるか確認します。  
- テストコードだけでは捉えきれない、ユーザ視点の使用感（表示メッセージの見やすさなど）を確かめるため。  
- いくつかのタスクを追加→一覧→完了→再度一覧という流れを試し、エラーメッセージや表示フォーマットを微調整します。

### 6.6.2 改良のステップ

1. **「del <ID>」で削除**  
   - タスクを削除する機能。  
   - 管理していれば不要になるタスクも出てくるため、ユーザのニーズに応えられる。  
   - 
     - 仕様策定: 削除成功時「Task #N removed.」などを表示し、ID不在ならエラーを返す。  
     - 実装: `DelTask(id int) error` を定義し、該当IDを線形探索で見つけたら `tasks = append(tasks[:i], tasks[i+1:]...)`  
     - テスト: 「正常削除」と「ID不在エラー」の2ケースで確認  

2. **ファイル保存 (Save/Load)**  
   - JSONファイル `tasks.json` に書き出し、再起動してもタスクが残るようにする。  
   - CLIアプリとはいえ、終了のたびにリセットされるのでは実用度が低い。  
   - 
     - `storage.go` に `SaveTasks(filename string, tasks []Task) error` / `LoadTasks(filename string) ([]Task, error)` を用意。  
     - JSONエンコード (`json.NewEncoder`) / デコード (`json.NewDecoder`) を使う。  
     - main.goの開始時に `tasks, _ = LoadTasks("tasks.json")`、終了時あるいはAdd/Done後に `SaveTasks("tasks.json", tasks)` を呼ぶなど運用設計を決める。

3. **並行処理リマインド**  
   - 例えば1分おきに「未完了タスクはX件あります」と表示する。  
   - タスクを忘れないための通知機能。Goの並行処理（goroutine）を体験する題材。  
   - 
     - `func startReminder()` で `ticker := time.NewTicker(1 * time.Minute)` → `for range ticker.C { ... }`  
     - ループ内で `range tasks` して Done=false の数を数え、メッセージ出力。  
     - Mutexが必要かは同時アクセスの有無を検討し、必要なら `sync.Mutex` で保護。

---

## 6.7 章末課題：仕様策定と開発フローを体験

### 6.7.1 バグ入りCLIのデバッグ演習

- 付録にある `cli_task_buggy` は8割完成のコードだが、複数のバグを含んでいる。具体的には「doneコマンドで特定条件下パニック」「list表示の不備」などが潜んでいる。  
- 実際の開発でも「仕様とコードの不一致」や「境界条件の見落とし」は起こりがち。バグ修正こそが学習の大きなステップ。  
- 
  1. `go test` でどこが落ちるか確認。エラーメッセージを読み、ソースコードを追う。  
  2. CLI上でも同じ手順を再現し、「なにが想定と違う挙動を引き起こすか」検証する。  
  3. コード修正 → 再度 `go test` & CLI操作 → 完全動作に到達するまで繰り返す。

### 6.7.2 仕様追加演習：削除コマンドの設計

- `del <ID>` でタスクを削除。成功時は「Task #N removed.」、ID不在はエラー表示。  
- タスク管理の基本操作として「もう完了したし、不要になった」といったケースをカバーするため。  
- 
  1. **仕様策定**: ユーザが削除後に再度`list`したら表示されないはず。  
  2. **実装**: `func DelTask(id int) error` を `task.go` に追加。  
  3. **テスト**: 正常削除（削除対象が見つかった場合）と、エラー（見つからない場合）の二通りを`_test.go`に書く。  
  4. **CLI**: main.go の `switch cmd` に `case "del":` を追加し、IDをパース→ `DelTask(id)` を呼ぶ→メッセージ表示。

### 6.7.3 リマインド機能の設計と実装

- 「`remind` コマンドを入れる」か、あるいは並行処理で一定時間ごとに未完了タスク数を通知するか、どちらか好きな方式を選択。  
- タスク管理は「登録するだけ」では実務に近づかない。リマインドや期限管理などの機能で、より汎用的に活用できる。  
- 
  1. コマンド版 → `remind` を呼ぶと、未完了タスクの一覧や数を表示する。  
  2. 並行処理版 → main() で `startReminder()` を呼び出し、1分ごとにルーチンが `ListTasks()` 相当の処理を自動実行。  
  3. いずれの場合も、「なにをどのタイミングで出力するか」を先に仕様として決め、テストや動作確認で間違いないか検証。

---

## 6.8 まとめ＆今後の展開

### 6.8.1 本章の要点

1. **仕様策定が第一**  
   - 「なにをするか」「なぜそうするか」を曖昧にせず、空タイトルをエラーにする理由や、ID不在でエラーにする理由などを**最初に決める**ことが、コードの迷走を防ぎます。  
   - 特に初心者は**先にコードを書きがち**ですが、短期で仕上げるためには**小さくても仕様を明文化**するのが近道です。

2. **CLI版タスク管理アプリは最適題材**  
   - GUIやWebフレームワークに時間を取られず、**Goのコア文法・データ構造・テスト・エラーハンドリング**を集中的に学べる。  
   - 完成度を上げた後に**Web版へ拡張**しやすく、大規模開発の第一歩として適切です。

3. **テストで仕様を守る**  
   - 仕様で定めた動作を維持するために、**正常系・異常系テスト**を両方用意します。  
   - 変更を加えてもテストが通るかぎり、基本的な仕様が崩れていないことを自動で保証できます。

4. **改良ステップを体験する**  
   - 削除機能、ファイル保存、並行リマインドなどを追加する際、**まず仕様を言語化→実装→テスト→動作確認**を回すサイクルを意識しましょう。  
   - 小規模アプリであっても、このサイクルを踏むことで**開発効率と品質が大きく向上**し、将来の大規模プロジェクトにも応用できる考え方が身につきます。

### 6.8.2 今後の展開

1. **第7章：Webアプリ化**  
   - 本章で作ったCLI版タスク管理アプリのビジネスロジックを流用し、`net/http` パッケージを使った**TodoリストWeb版**へ発展させます。  
   - CLIからHTTPへの移行を通じて、**「UIを変えても内部ロジックを使い回せる」**メリットを実感できるはずです。

2. **第8章：Lint・CI/CDなど品質アップ**  
   - Lintツール (`golangci-lint` 等) や GitHub Actions を導入し、**コミットのたびにテストと静的解析を自動実行**する流れを構築します。  
   - 本章のCLIアプリを題材に、**より実務的な品質管理**を学習してみてください。

3. **発展機能をさらに深掘り**  
   - 期限付きタスク（Deadline フィールドを導入し、期限切れを通知する）  
   - 優先度付きタスク（Priority int）やソート表示  
   - DB保存（`database/sql` や GORM）  
   - 大規模化のためのディレクトリ構造再設計  
   - これらも**仕様策定→実装→テスト→確認**のサイクルを踏むことで安定的に追加できます。

### 6.8.3 最後に

**本章では「CLI版タスク管理アプリ」を通じて、短期間かつ効率よく「なにをするか」「なぜそうするか」「どうやってやるか」を総合的に体感できるよう設計しました。** 小さなアプリとはいえ、仕様を明確にし、テストを整備しながら実装を進める流れは、あらゆるソフトウェア開発の基礎となります。

- 仕様策定でブレなくなる  
- テストで仕様を担保し続けられる  
- 改良を段階的に行うことで、短期でも完成度を上げられる

この学習ステップを踏むことで、**Go言語の基礎知識**と**開発フロー**が結びつき、次章でWeb版に拡張する際もスムーズに作業を進められるようになるでしょう。引き続き、**他の学習者や実務仲間とコードレビュー**をし合いながら、アプリを磨き上げてみてください。きっと、本章で培った小さな成功体験が、将来より大きなプロダクトを開発する際の大きなアドバンテージとなるはずです。
