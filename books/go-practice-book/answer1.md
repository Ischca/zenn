以下では、**第1章のミニテスト（1.7.1 選択問題、1.7.2 穴埋め問題）**に対応する解答例をまとめます。実際の書籍では、問題文とは別のページ（巻末付録など）に掲載する想定です。ここでは**解答と補足コメント**のみを記載します。

---

# 解答編：第1章ミニテスト

## 1.7.1 選択問題の解答

---

### 1. 「Goプログラムで実行ファイルを作るには」正しい方法はどれか

- **問題文**  
  1. (A) main 関数を作らずに `go run file.go` する  
  2. (B) `package main` & `func main()` を定義し、 `go build` or `go run` する  
  3. (C) ファイル名を `_main.gox` にすれば自動的に実行可能

- **解答**: (B)

- **解説**  
  - Go で実行可能プログラムを作るには、必ず **`package main`** と **`func main()`** が必要です。  
  - (A) は `main` 関数が無いと「実行可能プログラム」として動かせない。  
  - (C) は架空の拡張子であり、Go 言語が自動的に実行ファイルにする仕組みは存在しません。

---

### 2. 以下のコードについて正しい説明はどれか

```go
var name string
name = 123
```

- **選択肢**  
  - (A) `123` は数値なので型が合わず、コンパイルエラー  
  - (B) 自動で文字列化して `"123"` として格納  
  - (C) 実行時にエラーが出る

- **解答**: (A)

- **解説**  
  - Go は静的型付け言語であり、`name` が `string` と宣言されている場合、文字列以外を代入しようとするとコンパイル段階でエラーになります。自動的に `"123"` にはならないし、実行時エラーではなく**コンパイルエラー**です。

---

### 3. 下記の `:=` に関して正しいものはどれか

- **選択肢**  
  - (A) `:=` は関数の中でしか使えず、グローバルスコープでは使えない  
  - (B) すでに同名の変数が宣言済みでも `:=` で再宣言できる  
  - (C) 変数を変更するには常に `:=` が必要で `=` は使わない

- **解答**: (A)

- **解説**  
  - `:=` は**「宣言 + 初期化 + 型推論」**を同時に行う短縮記法で、**関数スコープ内**でのみ使用可能です。  
  - (B) は誤り（同じ名前の変数が既にあれば「再宣言」扱いになりコンパイルエラー）。  
  - (C) は不正（変数に値を変えたいだけなら `=` を使う）。

---

### 4. `const Pi = 3.14` と書いた場合、プログラムの途中で `Pi = 3.14159` と変更できるか？

- **選択肢**  
  - (A) できる。型が同じならOK  
  - (B) できない。コンパイルエラー  
  - (C) 実行時に警告が出るが動く

- **解答**: (B)

- **解説**  
  - Go の `const` は**値を変更不可**とする仕組みです。途中で書き換えようとすればコンパイルエラーとなります。

---

### 5. if 文で丸カッコをつけるかどうかについて、Go ではどう推奨されているか

- **選択肢**  
  - (A) `if x > 0 { ... }` のように `( )` は省略する  
  - (B) `( )` を必ず書かないとコンパイルエラー  
  - (C) `( )` を必ず書かないと読みづらいので警告が出る

- **解答**: (A)

- **解説**  
  - Go では**「if の条件式に丸カッコは付けない」**のが推奨スタイル。付けてもコンパイルは通りますが、慣習として省略されます。  
  - (B) は誤り（付けるとエラーではなく普通に動く）。(C) は警告も出ません。

---

## 1.7.2 穴埋め問題の解答

問題文（再掲）:
```go
package main
import "fmt"

func main() {
    // (A) の宣言: 整数型で変数として、初期値を 10 にする (var ... ?)
    // (B) の宣言: 定数MaxAgeを 120 として定義

    if (A) > 5 {
        fmt.Println("big")
    } else {
        fmt.Println("small")
    }

    // (C) forループで i=0 から i< (B) まで回し、 i を累積した sum を出力
    sum := 0
    for i := 0; i < (B); i++ {
        sum += i
    }
    fmt.Println("sum=", sum)
}
```

### (A) の宣言

- **解答例**: `var age int = 10`  
  - もしくは `age := 10` でも可(関数内だし短縮可)。  
  - ポイントは「整数型で変数に初期値10を与える」こと。

### (B) の宣言

- **解答例**: `const MaxAge = 120`  
  - 定数を表す `const` を使い、「MaxAge を 120」と決め打ち。

### (C) forループの条件

- for i := 0; i < **(B)**; i++  
  - つまり `i < MaxAge`。  
  - 上の宣言で (B) が `MaxAge` と書いたため、`(B)` 部分に `MaxAge` を挿入する。

よって完成形は:

```go
package main
import "fmt"

func main() {
    var age int = 10
    const MaxAge = 120

    if age > 5 {
        fmt.Println("big")
    } else {
        fmt.Println("small")
    }

    sum := 0
    for i := 0; i < MaxAge; i++ {
        sum += i
    }
    fmt.Println("sum=", sum)
}
```

---

# おわりに

これで、**第1章ミニテスト**（選択問題・穴埋め問題）に対応する**解答例**が揃いました。解答を参照しながら、不正解の理由や正解の意味を振り返ることで、

- **型(type)とは何か**  
- **変数/定数の宣言**  
- **Go の if / for / switch**  
- **Go の構文や慣習**  

について確認・定着できます。次章に進む前に、もし不安があれば本章のサンプルコードを何度か動かし、自分で「値や型を変えてみる→コンパイル結果をチェックする」実験をすると、**プログラムが型に基づいてどう動くか**を深く理解できるでしょう。