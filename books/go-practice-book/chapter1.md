---
title: "第1章：Goプログラミングの世界へ"
free: true
---

# 第1章　Goプログラミングの世界へ

## 1.1 はじめに

### 1.1.1 Go言語とは

Go 言語は、2009 年に Google が中心となって公開したプログラミング言語です。**シンプルな文法**や**高速コンパイル**、**並行処理のしやすさ**が特徴であり、近年さまざまな現場で採用が進んでいます。  
本書では、プログラミング初心者を想定して、Go 言語を**一から順を追って**解説します。プロの現場でも活用される言語を、**最初のプログラミング**として学べるよう、初歩的な内容からスタートし、徐々に応用的な機能へと進みます。

### 1.1.2 本章の目的

- **Go の実行方法**を体験し、最初の「Hello, World!」プログラムを動かす  
- **型(type)とは何か**、変数や定数を宣言する際にどのような役割を持つのかを理解する  
- **制御構文**（if, for, switch）をざっくり把握し、簡単なロジックを組む  
- 短い演習を通じて**手を動かして実行**し、「プログラムを変えて結果が変わる面白さ」を感じる

こうした基礎を押さえて、第2章以降でさらに**スライス・マップ・関数・構造体**といった要素へと進みます。まずは**Go 言語でプログラミングする**とはどういうことなのか、**型を意識して変数を扱う**とはどういうことなのかを一歩ずつ学んでいきましょう。

---

## 1.2 Go 言語の環境セットアップ (概要)

Go 言語を使うには、まず**コンパイラとツールチェーン**をインストールします。ここでは流れのみ概要を示し、細かい手順は付録や公式サイトなどをご覧ください。

1. **ダウンロード**:  
   - 公式サイト(https://go.dev/) にアクセスし、使用OSに対応するインストーラ（Windows 用、macOS 用、Linux 用など）を取得  
2. **インストール**:  
   - インストーラを実行。案内に従って進めると、`GOROOT` 等が自動設定される  
3. **確認**:  
   - ターミナル/コマンドプロンプトで `go version` を入力  
   - `go version go1.XX ...` と出れば成功

本書では、特定のエディタやIDEについては深入りせず、**テキストエディタ + ターミナル**での操作を前提に進めます。VSCode や GoLand などを使う方は、書いたコードを保存して「Run」ボタンを押すだけでも実行できます。

---

## 1.3 はじめての Go コード — Hello, World!

プログラミング初心者が最初に体験するお決まりのプログラム、「Hello, World!」をGo 言語で書いてみましょう。

### 1.3.1 ソースファイルの作成

新しいテキストファイル `main.go` を作り、以下の内容を入力してください。

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

- **`package main`**: このファイルが「実行可能プログラム」を表すパッケージであることを示す。  
- **`import "fmt"`**: Go の標準ライブラリ `fmt` を使うためにインポート。  
- **`func main()`**: プログラムが最初に実行を始める関数。ここに処理を書けば、その順序で動く。

### 1.3.2 `go run main.go` で実行

- ターミナル(またはコマンドプロンプト)で `cd` コマンド等を使い、`main.go` があるフォルダに移動  
- `go run main.go` と入力

結果として、

```
Hello, World!
```

と表示されるはずです。これが**Goプログラムの第一歩**です。「ソースコードを書き、`go run` で実行して結果を見る」サイクルを、本書で何度も繰り返します。

### 1.3.3 `go build` → 実行ファイル

```bash
go build main.go
```

このように打つと、同じフォルダに `main` (またはWindowsなら `main.exe`) という実行ファイルが生成されます。これを直接ダブルクリックしたり、`./main` とターミナルで打てば、「Hello, World!」が表示されます。配布するときに役立ちます。

---

## 1.4 型(type)とは何か

**プログラミング初心者**にとって、最初の大きな壁は「型って何だろう？」という疑問です。ここでは「型とは何か」を根本的なレベルで解説します。

### 1.4.1 型の基本概念

- **型 (type)** とは、一言で言えば「データの種類や構造」を表すラベルのようなもの。  
- 数値（整数/小数）、文字列、真偽値、複雑な構造など、プログラムが扱うあらゆる値には必ず「型」が存在します。  

#### 1.4.1.1 なぜ型が必要か

1. **メモリの管理**  
   - コンピュータはメモリにバイト列としてデータを格納しますが、「このバイト列をどう解釈するか？」を決めるのが型です。`int` なら 4 バイト or 8 バイトの整数として扱う、`string` なら文字列を格納する、といったように型ごとにメモリ上の構造を決めます。

2. **誤りを防ぐ (型安全性)**  
   - 例えば「文字列に対して四則演算をする」「小数に対して `%` 演算をする」といった無意味な操作を誤って書いても、型が異なればコンパイラがエラーを出して教えてくれます。

3. **可読性**  
   - コードを読む人にとって、「この変数は整数なんだな」「これは文字列なんだな」と分かることは大きな助けになります。

### 1.4.2 Go の基本データ型

Go 言語にはさまざまな型がありますが、まず以下の4つを押さえておけば十分です：

1. **整数型 (int)**  
   - `int` は環境によって 32ビット or 64ビットになりますが、初心者は細かいことを気にせず `int` でOKです。  
   - 必要に応じて `int8`, `int16`, `int64` など固定ビット長の整数型もありますが、それは後々で。
2. **浮動小数点 (float64)**  
   - 実数（小数）を扱う型。`float64` が一般的な倍精度浮動小数。  
   - `float32` は精度が低いがメモリを節約できる。初心者は `float64` と書くのが安全。
3. **文字列 (string)**  
   - ダブルクオート `"` で囲んでリテラルを表現。例："Hello"。  
   - Go の文字列は変更不可（イミュータブル）。文字列を連結すると新しい文字列が生成される仕組み。
4. **真偽値 (bool)**  
   - `true` か `false`。条件分岐で使う。

```go
var a int = 10
var b float64 = 3.14
var c string = "Go"
var d bool = true
```

- これらが「型と値を紐付け」する例です。Go ではこれらが**静的に**型付けされ、間違った操作をしようとするとコンパイルエラーを出します。

### 1.4.3 型変換について

Go では、「型が違う値同士を自動で混ぜる」ことはありません。例えば `int` と `float64` を足し算したいなら、明示的に片方を変換します。

```go
var i int = 10
var f float64 = 2.5

// sum := i + f // エラー
sum := float64(i) + f // OK: iをfloat64に変換
fmt.Println(sum) // 12.5
```

- `float64(i)` という書き方で「`i` (int) を float64 に変換」。こうすると型が一致し、演算可能になる。
- 自動変換しないのは、プログラマの意図しない型ミスを防ぐためのGo の方針です。

### 1.4.4 コンパイラによる型チェック

- Go は**静的型付け言語**であり、コンパイル時に「型が合わない操作がないか」などを厳しくチェックします。  
- その結果、実行前に多くのバグを検出できるメリットがあります。  
- 例: `var s string = 10` はコンパイルエラー。「文字列型なのに整数を代入してる！」

---

## 1.5 変数と定数の宣言方法 (Go特有の記法)

「型とは何か」を押さえたところで、Go で**変数や定数**を宣言する具体的な記法を改めて詳しく説明します。

### 1.5.1 変数宣言

#### 1.5.1.1 `var` キーワード

もっとも基本的なのは次の形式です。

```go
var 変数名 型
変数名 = 値
```

または

```go
var 変数名 型 = 初期値
```

- 例:  
  ```go
  var x int
  x = 10

  var y int = 20
  ```
- `x` は後から書き換え可能（ `x = 15` 等）。

#### 1.5.1.2 型の推論

Go は、右辺のリテラル（値）から型を推論できる場合、以下のように書けます。

```go
var z = 3.14 // zはfloat64と推論
```

これで `z` は `float64` 型と推論されるので、後から `z = "Hello"` のような代入はできません（型が違うためエラー）。

#### 1.5.1.3 `:=`（短縮宣言）

Go で**関数内**で変数を宣言する場合、しばしば `:=` を使います。

```go
func main() {
    x := 10       // int型
    name := "Bob" // string型
}
```

- これは「`var x int = 10` を短縮」したようなイメージで、**型推論 + 変数宣言 + 初期化**を一気に行うもの。  
- **既に x が宣言されている**場合、この書き方をすると「新たに x を宣言しようとしてコンパイルエラー」に。単に値を変えたいときは `x = 10` でよい。

### 1.5.2 定数 (constant)

**定数**は「プログラム中で変更してほしくない値」を固定する仕組みです。Go では `const` を使います。

```go
const Pi = 3.14159
```

- この `Pi` は後から `Pi = 3.14` のように書き換え不可。
- `const Version = "1.0.0"` と書けば、プログラム中にこのバージョンを共通参照できる。

#### 1.5.2.1 定数式

Go の定数は、文字列や数値の**演算結果**を含むこともできます。

```go
const TwoPi = 2 * Pi
```

実行時ではなく**コンパイル時**に評価されるため、例えば関数呼び出し結果など実行時に決定する値は `const` に代入できません（コンパイルエラーになる）。

---

## 1.6 制御構文: if, for, switch

プログラムは通常、「条件に応じた分岐」や「同じ処理の繰り返し」を要します。ここでは初心者が最初に覚える3つの制御構文を紹介します。

### 1.6.1 if ~ else

**条件分岐**を行うための構文です。Go では `if 条件 { ... } else { ... }` という形。

```go
score := 75
if score >= 60 {
    fmt.Println("Pass")
} else {
    fmt.Println("Fail")
}
```

- もし `score` が 60以上なら「Pass」、そうでなければ「Fail」。
- `if (score >= 60) { ... }` と書いても動くが、丸カッコは書かないのが基本スタイル。
- `else if score >= 80 { ... }` と並べることで、多段階分岐もできます。

### 1.6.2 for ループ

**繰り返し**を行うための構文です。

#### 1.6.2.1 カウンタ付き for

```go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
---
0
1
2
3
4
```

#### 1.6.2.2 条件のみ

```go
x := 5
for x > 0 {
    fmt.Println(x)
    x--
}
---
5
4
3
2
1
```

#### 1.6.2.3 無限ループ

```go
for {
    // breakやreturnで抜けなければ永遠に回る
}
```

- `break` 文を使えばループを抜けられる。`continue` で次の反復に移るなどの制御も可能。

### 1.6.3 switch

複数の `case` を並べることで、多岐分岐を表現します。

```go
color := "blue"
switch color {
    case "red":
        fmt.Println("Color is red")
    case "blue":
        fmt.Println("Color is blue")
    default:
        fmt.Println("Unknown color")
}
```

- `default` はどの case にも該当しない場合に実行される。
- 複数のcaseをまとめる方法(`fallthrough`)や、条件式を使う方法もありますが、基本的にはこの形式で十分です。

---

## 1.7 ミニテスト — 第1章の復習

ここで、本章の内容（型とは何か／変数と定数／制御構文／Go の実行手順）を対象に、**紙面で答えられるミニテスト**を用意します。解答は巻末などに掲載されています。実際にコードを動かさなくても、論理的に回答可能な問題になっています。

### 1.7.1 選択問題

1. **型(type)の役割**として最も適切なのはどれか  
   - (A) メモリ上でデータをどのように解釈・扱うかを決める  
   - (B) プログラムを高速に走らせるためだけに存在する  
   - (C) コンパイル時に無視されるラベルにすぎない  

2. 次のコードについて正しい説明を選んでください  
   ```go
   var name string
   name = 123
   ```
   - (A) `123` は数値なので型が合わず、コンパイルエラーになる  
   - (B) 自動で文字列化して「"123"」として格納される  
   - (C) 実行時にエラーが出る  

3. 下記の`:=` に関して正しいものはどれか  
   - (A) `:=` は関数の中でしか使えず、グローバルスコープでは使えない  
   - (B) すでに同名の変数が宣言済みでも `:=` で再宣言できる  
   - (C) 変数を変更するには常に `:=` が必要で `= ` は使わない  

4. `const Pi = 3.14` と書いた場合、プログラムの途中で `Pi = 3.14159` と変更できるか？  
   - (A) できる。型が同じならOK  
   - (B) できない。コンパイルエラーになる  
   - (C) 実行時に警告が出るが動く  

5. if 文で丸カッコをつけるかどうかについて、Go ではどう推奨されているか  
   - (A) できれば `( )` は省略し、 `if x > 0 { ... }` のように書く  
   - (B) `( )` を必ず書かないとコンパイルエラー  
   - (C) `( )` を必ず書かないと読みづらいので警告が出る  

### 1.7.2 穴埋め問題

```go
package main
import "fmt"

func main() {
    // (A) の宣言: 整数型で変数として、初期値を 10 にする (var ... ?)
    // (B) の宣言: 定数MaxAgeを 120 として定義

    if (A) > 5 {
        fmt.Println("big")
    } else {
        fmt.Println("small")
    }

    // (C) forループで i=0 から i< (B) まで回し、 i を累積した sum を出力
    sum := 0
    for i := 0; i < (B); i++ {
        sum += i
    }
    fmt.Println("sum=", sum)
}
```

- (A): 変数宣言 (例: `var age int = 10` など)  
- (B): 定数 (例: `const MaxAge = 120` )  
- (C): for 文の中で `i < MaxAge` のように書きたい

---

## 1.8 ミニ演習：型を意識したプログラム

ここでは短い演習を示します。**実際にファイルを作り、コンパイル・実行**してください。型や変数についてより深く理解できるでしょう。

### 1.8.1 指示

1. **ファイル名**: `main.go`  
2. 内容:  
   - `package main` & `import "fmt"` は必須  
   - `func main()` 内で以下を行う
     1. `const Pi = 3.14` として定数を宣言
     2. `var r float64 = 2.5` として半径 r を決める
     3. 円の面積を「`Pi * r * r`」で計算する (型は float64)
     4. `fmt.Println` で「Area= ...」と表示
     5. `if area >= 20.0 { ... } else { ... }` の条件分岐で「large」 or 「small」と出力

### 1.8.2 例コード

```go
package main
import "fmt"

func main() {
    const Pi = 3.14
    var r float64 = 2.5
    area := Pi * r * r
    fmt.Println("Area =", area)

    if area >= 20.0 {
        fmt.Println("large")
    } else {
        fmt.Println("small")
    }
}
```

- 実行結果の一例：  
  ```
  Area = 19.625
  small
  ```
- `r` の値や判定基準を変えながら動かしてみると、**型を変更するとエラーが出る場合**や**判定が通らなくなる場合**などを観察できる。

---

## 1.9 まとめ

1. **Go 言語の実行**:  
   - ソースコードに `package main` と `func main()` を書く → `go run main.go` or `go build main.go` で実行  
   - "Hello, World!" で最初のプログラムを体感
2. **型(type)とは**:  
   - 「データがどのようにメモリに置かれ、どのように操作されるかを決めるルール」  
   - 整数 `int`、小数 `float64`、文字列 `string`、真偽値 `bool` が基本  
   - Go は静的型付け言語であり、異なる型同士の演算はコンパイラが拒否する
3. **変数と定数**:  
   - 変数: `var x int` / `x = 10` と書き換え自由  
   - 定数: `const Pi = 3.14` で書き換え不可  
   - `:=` は関数内で使える「宣言 + 初期化 + 型推論」を同時に行う短縮記法
4. **制御構文**:  
   - `if ~ else`: 条件分岐  
   - `for`: 繰り返し (カウンタ式 / 条件式 / 無限ループ)  
   - `switch`: 多岐分岐 (caseごとに自動 `break`)  
5. **ミニテスト**:  
   - 紙面で答えられる問題で、型/変数/制御構文/Go の基本を復習  
6. **ミニ演習**:  
   - 実際にファイルを作成し、Go コードを書いてコンパイル → 実行  
   - 変数の型を変えてみたり、定数を変えてみたりしながら動きの違いを確認

本章で学んだのは、**プログラミングにおける最低限の概念**です。Go 言語を学ぶうえで、「型の存在意義」「変数をどう扱うか」「制御構文でどのように処理を分岐/反復するか」は、**すべての土台**と言えます。次章では、より実務的なデータ管理を可能にする**スライス (slice) やマップ (map)** を取り上げ、たくさんの要素を扱う方法を学びます。  
引き続き、**小さなコードでもいいから自分で書いて動かす**練習を重ね、**Go の文法 + 型の考え方**に慣れていきましょう。